# 决策记录

## 决策记录格式

每次重要决策请按照以下格式记录：

### YYYY-MM-DD HH:MM:SS

**决策的背景**：描述当时的情况和问题
**决策的内容**：具体的决策事项
**决策的原因**：为什么做出这个决策
**决策的结果**：决策实施后的效果

---

## 决策记录

### 2026-02-03 16:30:00

**决策的背景**：用户在 Linux 服务器上执行 `docker compose up -d` 时出现报错，需要分析原因并提供解决方案
**决策的内容**：
1. 将 MySQL 初始化脚本从 Python 脚本改为 SQL 脚本
2. 修复前端 Dockerfile 中的 npm 安装问题
3. 简化 Nginx 用户权限配置
**决策的原因**：
1. MySQL 官方镜像的 `/docker-entrypoint-initdb.d/` 只支持 `.sh`、`.sql`、`.sql.gz` 格式，Python 脚本无法被执行，这是导致数据库表无法自动创建的主要原因
2. 项目没有 `package-lock.json` 文件，使用 `npm ci` 会失败，需要改用 `npm install`
3. Nginx 使用非 root 用户可能导致权限问题，简化配置以提高兼容性
**决策的结果**：
- 创建了 `scripts/init_db.sql` 文件，包含完整的数据库表结构
- 更新了 `docker-compose.yml` 使用新的 SQL 初始化脚本
- 修复了前端 Dockerfile，使其能在没有 package-lock.json 的情况下正常构建
- 简化了 Nginx 配置，移除了可能导致权限问题的非 root 用户设置

### 2026-02-04 09:43:26

**决策的背景**：需要为系统新增登录与用户管理模块，同时避免与现有后端 API 响应风格产生割裂，降低联调与迁移成本
**决策的内容**：后端沿用现有接口风格：成功响应直接返回业务数据；失败响应使用HTTP状态码表达语义并通过detail返回错误信息；前端通过Axios拦截器与路由守卫实现鉴权闭环
**决策的原因**：
1. 现有 endpoints 已广泛使用"成功直返业务数据 + HTTPException(detail)"模式，强行切换统一包装会引入大范围改动与兼容成本
2. 保持HTTP状态码语义有利于错误处理、监控统计与标准化客户端行为
3. 鉴权逻辑集中在拦截器/守卫可减少页面重复代码并提升一致性
**决策的结果**：形成并新增《登录与用户管理模块实施方案（gpt-5.2）》文档，明确接口形状与前后端接入方式，作为后续实现的依据

### 2026-02-04 10:00:00

**决策的背景**：根据实施方案全面开发登录与用户管理模块，需要做出多个技术决策
**决策的内容**：
1. Token存储方案：使用localStorage存储JWT Token
2. 密码加密方案：使用bcrypt进行密码哈希，限制密码长度不超过72字节
3. 验证码方案：使用PIL生成图形验证码，4位数字+字母，5分钟有效期，一次性使用
4. 登录安全策略：连续5次失败锁定15分钟
5. 权限模型：RBAC最小集，admin和user两个角色
6. 后端接口风格：沿用现有风格，成功直接返回数据，失败使用HTTP状态码+detail
**决策的原因**：
1. localStorage适合与现有项目轻量接入，后续可迭代更安全的方案
2. bcrypt是业界标准，72字节限制是bcrypt算法的安全限制
3. 图形验证码简单有效，4位长度兼顾安全性和用户体验
4. 5次失败+15分钟锁定是业界常见的防暴力破解策略
5. RBAC最小集满足当前需求，后续可扩展更细粒度权限
6. 沿用现有风格保持代码一致性，降低集成成本
**决策的结果**：
- 完成后端认证模块（验证码、登录、登出、用户信息）
- 完成用户管理API（列表、创建、编辑、删除、重置密码）
- 完成个人中心API（查看、修改资料、修改密码）
- 完成前端登录页面、用户管理页面、个人中心页面
- 完成路由守卫和Axios拦截器实现鉴权闭环
- 创建初始化脚本生成默认管理员账号（admin/admin123）

### 2026-02-04 11:20:00

**决策的背景**：开发环境（Windows 本地）前端大量依赖 localhost；生产环境（Docker）前后端分离部署，前端容器/用户浏览器侧的 localhost 无法指向后端容器，且将 baseURL 改为相对路径后本地验证码请求异常
**决策的内容**：前端 API 统一采用"相对路径 + 反向代理"方式：baseURL 默认使用 /api/v1，并允许通过 VITE_API_BASE_URL 覆盖；开发环境使用 Vite proxy 将 /api 请求转发到本地后端（target 可通过 VITE_DEV_PROXY_TARGET 配置）
**决策的原因**：
1. 相对路径可天然适配 Docker 部署的 Nginx 同源反代，避免写死 host/port 与 localhost 语义歧义
2. 通过 dev proxy 保持本地开发体验不变（仍可连接 localhost:8000 后端），同时不污染生产构建产物
3. 环境变量覆盖为后续接入不同网关/端口提供最小成本的配置入口
**决策的结果**：开发环境验证码与登录请求恢复正常；生产环境可通过 Nginx 反代稳定访问后端，降低"误连测试库/本地后端"的风险

### 2026-02-05 10:00:00

**决策的背景**：用户要求在本地直接运行本项目的前后端服务（非docker运行），并且不允许修改环境变量文件，需要使用原始的MySQL数据库连接信息
**决策的内容**：
1. 恢复MySQL连接池参数配置：移除SQLite条件判断，恢复使用MySQL连接池参数的配置
2. 配置前端API基础URL：创建frontend/.env文件，设置正确的后端API地址为http://localhost:8000/api/v1
3. 启动前后端服务：使用原始环境变量文件中的MySQL数据库连接信息，在本地启动后端和前端服务
**决策的原因**：
1. 根据用户要求，必须使用原始环境变量文件中的MySQL数据库连接信息，需要恢复MySQL连接池参数配置
2. 前端需要配置正确的后端API地址，才能正常连接到后端服务
3. 需要在本地启动前后端服务，验证系统是否可以正常运行
**决策的结果**：
- 后端服务成功启动，连接到MySQL数据库（10.21.65.20:3307）
- 前端服务成功启动，配置了正确的API基础URL
- 系统可以正常访问，前端能够正确连接到后端API
- 无错误，页面可以正常加载

### 2026-02-05 09:25:00

**决策的背景**：前端页面登录时显示"网络连接失败，请检查网络"错误，浏览器控制台显示 `net::ERR_FAILED` 错误。经分析，根本原因是后端CORS配置违规：当 `allow_credentials=True` 时，`allow_origins` 不能使用通配符 `*`，这违反了CORS规范，导致浏览器阻止跨域请求。
**决策的内容**：
将 `app/config.py` 中的 `BACKEND_CORS_ORIGINS` 配置从 `["*"]` 修改为明确指定前端地址 `["http://localhost:5173", "http://localhost:3000"]`
**决策的原因**：
1. CORS规范要求：当 `Access-Control-Allow-Credentials` 为 true 时，`Access-Control-Allow-Origin` 不能使用通配符 `*`，必须明确指定允许的源
2. 明确指定允许的源是更安全的做法，避免允许来自任何域的请求
3. 这是导致 `net::ERR_FAILED` 错误的根本原因，只有修复CORS配置才能解决问题
**决策的结果**：
- 修改后的CORS配置符合规范，OPTIONS预检请求返回正确的响应头：`access-control-allow-origin: http://localhost:5173` 和 `access-control-allow-credentials: true`
- 后端服务重启后新配置生效
- 前端可以正常跨域访问后端API，登录功能恢复正常

### 2026-02-05 11:26

**决策的背景**：前端登录报错问题综合修复方案v4分析发现，前端使用完整URL `http://localhost:8000/api/v1` 直接请求后端，导致跨域问题。虽然后端CORS配置已修复，但使用Vite代理是开发环境的标准做法。
**决策的内容**：
将前端 `frontend/.env` 文件中的 `VITE_API_BASE_URL` 从 `http://localhost:8000/api/v1` 修改为相对路径 `/api/v1`
**决策的原因**：
1. 使用相对路径可以让请求经过Vite代理，避免浏览器跨域限制
2. 代理在服务器端转发请求，浏览器看到的是同源请求
3. 这是开发环境的标准做法，比直接配置CORS更可靠
4. 配合Vite已有的代理配置，`/api` 规则可以正确拦截并转发请求
**决策的结果**：
- 前端请求将通过Vite代理转发到后端
- 从根本上解决跨域问题，登录功能恢复正常
- 浏览器控制台不再有CORS错误
- 前端配置与Vite代理正确配合，开发环境运行稳定

### 2026-02-05 14:30

**决策的背景**：前端登录报错问题在修复后经验证仍然存在问题。经过系统调试发现两个根本原因：1) `frontend/.env` 文件缺失（只有 `.env.bak` 备份文件）；2) 系统存在全局代理设置 `http_proxy=http://10.15.136.20:8080`，导致请求被Squid代理拦截返回503错误。
**决策的内容**：
1. 创建 `frontend/.env` 文件，设置 `VITE_API_BASE_URL=/api/v1`
2. 设置系统环境变量 `NO_PROXY=localhost,127.0.0.1,::1` 和 `no_proxy=localhost,127.0.0.1,::1`
3. 重启前后端服务以应用新的环境变量
**决策的原因**：
1. `.env` 文件缺失导致Vite无法加载环境变量，前端API配置不正确
2. 系统代理设置会拦截所有HTTP请求，包括发往localhost的请求，必须通过NO_PROXY排除本地地址
3. 环境变量修改后必须重启服务才能生效
**决策的结果**：
- 创建了缺失的 `.env` 文件，前端环境变量配置正确
- 设置了NO_PROXY环境变量，本地请求不再被代理拦截
- 后端服务正常响应，API返回200状态码
- 前端登录功能恢复正常，可以正常获取验证码和登录

### 2026-02-06 18:00:00

**决策的背景**：设备列表显示问题：前端设备选择器在设备数量超过默认分页大小时，无法显示完整的设备列表，导致用户无法选择所有设备进行批量操作。
**决策的内容**：
1. 后端新增 `/devices/all` API端点，支持获取所有设备列表（不受分页限制）
2. 前端新增 `getAllDevices` API方法，调用新的后端端点
3. 修改 `ConfigurationManagement.vue` 中的设备加载逻辑，使用新的API
4. 添加设备选择器去重逻辑，使用Set确保设备ID唯一性
5. 完善错误处理和加载状态提示
**决策的原因**：
1. 现有 `/devices` API使用分页（page/page_size），默认只返回10条记录，无法满足设备选择器需要完整列表的需求
2. 新增独立的 `/devices/all` 端点可以明确区分分页列表和完整列表的使用场景
3. 添加limit限制（默认100，最大5000）防止一次性加载过多数据导致性能问题
4. 支持status和vendor筛选参数，保持与现有API一致的筛选能力
5. 使用Set去重可以避免用户操作导致的重复选择问题
**决策的结果**：
- 后端新增 `/devices/all` API端点，支持limit、offset、status、vendor参数
- 前端新增 `getAllDevices` 方法，默认获取100条设备记录
- 配置管理页面的设备选择器现在可以正确加载完整设备列表
- 全选功能使用Set去重，避免重复选择
- 添加了详细的错误处理和加载状态提示，提升用户体验
