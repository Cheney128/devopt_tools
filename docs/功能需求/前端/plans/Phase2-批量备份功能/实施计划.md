# Phase 2: 批量备份功能

> **For Claude:** REQUIRED SUB-SKILL: 使用 superpowers:subagent-driven-development 或 superpowers:executing-plans 实施此计划。

**目标:** 实现一键批量备份所有设备的功能，包括后端API和前端UI，提供备份进度展示和结果反馈。

**架构说明:**
- 后端新增 `/configurations/backup-all` 异步API
- 前端新增"备份所有设备"按钮和进度展示
- 支持按状态、厂商筛选设备进行备份
- 提供实时进度和结果展示
- **新增**: 任务状态持久化、并发控制、取消任务、错误重试机制

**技术栈:**
- 后端: FastAPI, SQLAlchemy, APScheduler, asyncio
- 前端: Vue 3, Element Plus, Axios, WebSocket（可选）

---

## 任务拆解

### 任务0: 数据库模型设计（前置任务）

**涉及文件:**
- 修改: `app/models/models.py`
- 新增: `app/models/backup_task.py`
- 新增: `alembic/versions/xxx_add_backup_task_table.py`

**Step 1: 编写失败的测试**

```python
# tests/unit/test_backup_task_model.py
import pytest
from datetime import datetime
from app.models.backup_task import BackupTask, BackupTaskStatus

class TestBackupTaskModel:
    """备份任务模型测试"""

    def test_create_backup_task(self, db_session):
        """测试创建备份任务"""
        task = BackupTask(
            task_id="test-task-001",
            status=BackupTaskStatus.PENDING,
            total=10,
            filters={"filter_status": "online"}
        )
        db_session.add(task)
        db_session.commit()

        saved_task = db_session.query(BackupTask).filter_by(task_id="test-task-001").first()
        assert saved_task is not None
        assert saved_task.status == BackupTaskStatus.PENDING
        assert saved_task.total == 10

    def test_update_task_status(self, db_session):
        """测试更新任务状态"""
        task = BackupTask(
            task_id="test-task-002",
            status=BackupTaskStatus.PENDING,
            total=5
        )
        db_session.add(task)
        db_session.commit()

        task.status = BackupTaskStatus.RUNNING
        task.completed = 2
        task.success_count = 2
        db_session.commit()

        updated_task = db_session.query(BackupTask).filter_by(task_id="test-task-002").first()
        assert updated_task.status == BackupTaskStatus.RUNNING
        assert updated_task.completed == 2
```

**Step 2: 运行测试验证失败**

```bash
cd d:\BaiduSyncdisk\5.code\netdevops\switch_manage
pytest tests/unit/test_backup_task_model.py -v
```

预期: FAIL - `BackupTask` 模型不存在

**Step 3: 实现备份任务模型**

```python
# app/models/backup_task.py
from sqlalchemy import Column, Integer, String, DateTime, JSON, Enum as SQLEnum
from sqlalchemy.sql import func
from enum import Enum
import uuid

from app.database import Base


class BackupTaskStatus(str, Enum):
    """备份任务状态枚举"""
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"


class BackupPriority(str, Enum):
    """备份任务优先级枚举"""
    LOW = "low"
    NORMAL = "normal"
    HIGH = "high"


class BackupTask(Base):
    """备份任务模型"""
    __tablename__ = "backup_tasks"

    id = Column(Integer, primary_key=True, index=True)
    task_id = Column(String(36), unique=True, index=True, nullable=False)
    status = Column(SQLEnum(BackupTaskStatus), default=BackupTaskStatus.PENDING)
    priority = Column(SQLEnum(BackupPriority), default=BackupPriority.NORMAL)
    total = Column(Integer, default=0)
    completed = Column(Integer, default=0)
    success_count = Column(Integer, default=0)
    failed_count = Column(Integer, default=0)
    filters = Column(JSON, default=dict)
    max_concurrent = Column(Integer, default=3)
    timeout = Column(Integer, default=300)
    retry_count = Column(Integer, default=2)
    notify_on_complete = Column(Integer, default=0)  # 0=False, 1=True
    created_by = Column(String(100), nullable=True)
    error_details = Column(JSON, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    started_at = Column(DateTime(timezone=True), nullable=True)
    completed_at = Column(DateTime(timezone=True), nullable=True)

    def __init__(self, **kwargs):
        if 'task_id' not in kwargs:
            kwargs['task_id'] = str(uuid.uuid4())
        super().__init__(**kwargs)

    def to_dict(self):
        """转换为字典"""
        return {
            "task_id": self.task_id,
            "status": self.status.value,
            "priority": self.priority.value,
            "total": self.total,
            "completed": self.completed,
            "success_count": self.success_count,
            "failed_count": self.failed_count,
            "filters": self.filters,
            "max_concurrent": self.max_concurrent,
            "timeout": self.timeout,
            "retry_count": self.retry_count,
            "notify_on_complete": bool(self.notify_on_complete),
            "created_by": self.created_by,
            "error_details": self.error_details,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "started_at": self.started_at.isoformat() if self.started_at else None,
            "completed_at": self.completed_at.isoformat() if self.completed_at else None,
            "progress_percentage": self.progress_percentage
        }

    @property
    def progress_percentage(self) -> float:
        """计算进度百分比"""
        if self.total == 0:
            return 100.0
        return round((self.completed / self.total) * 100, 2)
```

**Step 4: 创建数据库迁移脚本**

```bash
alembic revision --autogenerate -m "add backup_tasks table"
alembic upgrade head
```

**Step 5: 运行测试验证通过**

```bash
pytest tests/unit/test_backup_task_model.py -v
```

预期: PASS

**Step 6: 提交变更**

```bash
git add app/models/backup_task.py tests/unit/test_backup_task_model.py alembic/versions/
git commit -m "feat: 添加备份任务数据库模型"
```

---

### 任务1: 后端新增 `/configurations/backup-all` API

**涉及文件:**
- 修改: `app/routers/configurations.py`
- 新增: `app/schemas/backup.py`
- 新增: `app/services/backup_executor.py`
- 新增: `tests/unit/test_backup_all_api.py`

**Step 1: 编写失败的测试**

```python
# tests/unit/test_backup_all_api.py
import pytest
from fastapi.testclient import TestClient
from unittest.mock import AsyncMock, patch, MagicMock
from app.main import app

class TestBackupAllAPI:
    """备份所有设备API测试"""

    def test_backup_all_returns_task_id(self):
        """测试备份所有设备返回任务ID"""
        client = TestClient(app)
        
        response = client.post("/configurations/backup-all", json={
            "filter_status": None,
            "filter_vendor": None,
            "async_execute": True,
            "max_concurrent": 3,
            "retry_count": 2
        })
        
        assert response.status_code == 200
        data = response.json()
        assert "task_id" in data
        assert "total" in data
        assert "message" in data

    def test_backup_all_with_status_filter(self):
        """测试按状态筛选备份"""
        client = TestClient(app)
        
        response = client.post("/configurations/backup-all", json={
            "filter_status": "online",
            "filter_vendor": None,
            "async_execute": True
        })
        
        assert response.status_code == 200
        data = response.json()
        assert data["total"] >= 0

    def test_backup_all_with_vendor_filter(self):
        """测试按厂商筛选备份"""
        client = TestClient(app)
        
        response = client.post("/configurations/backup-all", json={
            "filter_status": None,
            "filter_vendor": "Cisco",
            "async_execute": True
        })
        
        assert response.status_code == 200
        data = response.json()
        assert "task_id" in data

    def test_backup_all_sync_execution(self):
        """测试同步执行备份"""
        client = TestClient(app)
        
        response = client.post("/configurations/backup-all", json={
            "filter_status": None,
            "filter_vendor": None,
            "async_execute": False
        })
        
        assert response.status_code == 200
        data = response.json()
        assert "results" in data

    def test_get_backup_task_status(self):
        """测试获取备份任务状态"""
        client = TestClient(app)
        
        # 先创建任务
        response = client.post("/configurations/backup-all", json={
            "async_execute": True
        })
        task_id = response.json()["task_id"]
        
        # 查询任务状态
        response = client.get(f"/configurations/backup-tasks/{task_id}")
        assert response.status_code == 200
        data = response.json()
        assert data["task_id"] == task_id
        assert "status" in data

    def test_cancel_backup_task(self):
        """测试取消备份任务"""
        client = TestClient(app)
        
        # 先创建任务
        response = client.post("/configurations/backup-all", json={
            "async_execute": True
        })
        task_id = response.json()["task_id"]
        
        # 取消任务
        response = client.post(f"/configurations/backup-tasks/{task_id}/cancel")
        assert response.status_code == 200
```

**Step 2: 运行测试验证失败**

```bash
cd d:\BaiduSyncdisk\5.code\netdevops\switch_manage
pytest tests/unit/test_backup_all_api.py -v
```

预期: FAIL - `/configurations/backup-all` 端点不存在

**Step 3: 定义请求/响应Schema**

```python
# app/schemas/backup.py
from pydantic import BaseModel, Field, validator
from typing import Optional, List, Dict, Any
from enum import Enum
from datetime import datetime


class BackupPriority(str, Enum):
    """备份优先级"""
    LOW = "low"
    NORMAL = "normal"
    HIGH = "high"


class BackupTaskStatus(str, Enum):
    """备份任务状态"""
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"


class BackupFilter(BaseModel):
    """备份筛选条件"""
    filter_status: Optional[str] = Field(None, description="按设备状态筛选 (online/offline/maintenance)")
    filter_vendor: Optional[str] = Field(None, description="按厂商筛选")
    async_execute: bool = Field(True, description="是否异步执行")
    notify_on_complete: bool = Field(False, description="完成后是否通知")
    priority: BackupPriority = Field(BackupPriority.NORMAL, description="任务优先级")
    max_concurrent: int = Field(3, ge=1, le=10, description="最大并发数")
    timeout: int = Field(300, ge=60, le=3600, description="单设备超时时间（秒）")
    retry_count: int = Field(2, ge=0, le=5, description="失败重试次数")
    
    @validator('filter_status')
    def validate_status(cls, v):
        if v and v not in ['online', 'offline', 'maintenance']:
            raise ValueError('无效的设备状态')
        return v


class BackupTaskResponse(BaseModel):
    """备份任务响应"""
    task_id: str
    status: BackupTaskStatus
    total: int
    completed: int = 0
    success_count: int = 0
    failed_count: int = 0
    message: str
    created_at: datetime
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    progress_percentage: float = 0.0
    
    class Config:
        from_attributes = True


class BackupResultItem(BaseModel):
    """单个设备备份结果"""
    device_id: int
    device_name: str
    success: bool
    config_id: Optional[int] = None
    error_message: Optional[str] = None
    error_code: Optional[str] = None
    execution_time: Optional[float] = None
    config_size: Optional[int] = None
    git_commit_id: Optional[str] = None


class BackupTaskDetailResponse(BackupTaskResponse):
    """备份任务详情响应"""
    errors: List[Dict[str, Any]] = []
    results: Optional[List[BackupResultItem]] = None


class BackupTaskListResponse(BaseModel):
    """备份任务列表响应"""
    tasks: List[BackupTaskResponse]
    total: int
    page: int
    page_size: int


class CancelTaskResponse(BaseModel):
    """取消任务响应"""
    message: str
    task_id: str
```

**Step 4: 实现批量备份执行器（带并发控制和重试）**

```python
# app/services/backup_executor.py
import asyncio
import logging
from datetime import datetime
from typing import List, Dict, Any, Optional
from sqlalchemy.orm import Session

from app.models.models import Device
from app.models.backup_task import BackupTask, BackupTaskStatus

logger = logging.getLogger(__name__)


class BackupExecutor:
    """批量备份执行器 - 支持并发控制和失败重试"""
    
    def __init__(self, max_concurrent: int = 3, timeout: int = 300):
        self.max_concurrent = max_concurrent
        self.timeout = timeout
        self.semaphore = asyncio.Semaphore(max_concurrent)
        self._cancelled_tasks: set = set()
    
    def cancel_task(self, task_id: str):
        """标记任务为取消状态"""
        self._cancelled_tasks.add(task_id)
    
    def is_task_cancelled(self, task_id: str) -> bool:
        """检查任务是否被取消"""
        return task_id in self._cancelled_tasks
    
    async def execute_backup_all(
        self,
        task_id: str,
        device_ids: List[int],
        db: Session,
        retry_count: int = 2
    ) -> Dict[str, Any]:
        """
        执行批量备份
        
        Args:
            task_id: 任务ID
            device_ids: 设备ID列表
            db: 数据库会话
            retry_count: 失败重试次数
        
        Returns:
            执行结果
        """
        from app.routers.configurations import get_backup_task_db
        
        task = get_backup_task_db(task_id, db)
        if not task:
            raise ValueError(f"任务不存在: {task_id}")
        
        task.status = BackupTaskStatus.RUNNING
        task.started_at = datetime.now()
        db.commit()
        
        results = []
        
        async def execute_with_retry(device_id: int) -> Dict[str, Any]:
            """执行单个设备备份，带重试机制"""
            async with self.semaphore:
                # 检查任务是否被取消
                if self.is_task_cancelled(task_id):
                    return {
                        "device_id": device_id,
                        "success": False,
                        "error_message": "任务已取消",
                        "error_code": "TASK_CANCELLED"
                    }
                
                for attempt in range(retry_count + 1):
                    try:
                        result = await self._execute_single_backup(
                            device_id, db, task_id
                        )
                        
                        # 更新任务进度
                        task.completed += 1
                        if result.get("success"):
                            task.success_count += 1
                        else:
                            task.failed_count += 1
                        db.commit()
                        
                        return result
                    except Exception as e:
                        logger.warning(
                            f"设备 {device_id} 第 {attempt + 1} 次备份失败: {str(e)}"
                        )
                        if attempt == retry_count:
                            task.completed += 1
                            task.failed_count += 1
                            db.commit()
                            return {
                                "device_id": device_id,
                                "success": False,
                                "error_message": str(e),
                                "error_code": "MAX_RETRIES_EXCEEDED"
                            }
                        # 指数退避等待
                        await asyncio.sleep(2 ** attempt)
                
                return {
                    "device_id": device_id,
                    "success": False,
                    "error_message": "未知错误"
                }
        
        # 并发执行所有设备备份
        tasks = [execute_with_retry(device_id) for device_id in device_ids]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # 处理异常结果
        processed_results = []
        errors = []
        for r in results:
            if isinstance(r, Exception):
                error_result = {
                    "device_id": None,
                    "success": False,
                    "error_message": str(r),
                    "error_code": "EXECUTION_ERROR"
                }
                processed_results.append(error_result)
                errors.append(error_result)
            else:
                processed_results.append(r)
                if not r.get("success"):
                    errors.append(r)
        
        # 更新任务最终状态
        if self.is_task_cancelled(task_id):
            task.status = BackupTaskStatus.CANCELLED
        elif task.failed_count == 0:
            task.status = BackupTaskStatus.COMPLETED
        elif task.success_count == 0:
            task.status = BackupTaskStatus.FAILED
        else:
            task.status = BackupTaskStatus.COMPLETED  # 部分成功也算完成
        
        task.completed_at = datetime.now()
        task.error_details = {"errors": errors} if errors else None
        db.commit()
        
        # 清理取消标记
        self._cancelled_tasks.discard(task_id)
        
        return {
            "task_id": task_id,
            "total": len(device_ids),
            "completed": task.completed,
            "success_count": task.success_count,
            "failed_count": task.failed_count,
            "results": processed_results
        }
    
    async def _execute_single_backup(
        self,
        device_id: int,
        db: Session,
        task_id: str
    ) -> Dict[str, Any]:
        """执行单个设备备份"""
        device = db.query(Device).filter(Device.id == device_id).first()
        if not device:
            return {
                "device_id": device_id,
                "success": False,
                "error_message": f"设备不存在: {device_id}",
                "error_code": "DEVICE_NOT_FOUND"
            }
        
        start_time = datetime.now()
        
        try:
            # 使用现有的备份调度器服务
            from app.services.backup_scheduler import BackupSchedulerService
            scheduler = BackupSchedulerService()
            result = await scheduler._execute_single_backup(device_id)
            
            execution_time = (datetime.now() - start_time).total_seconds()
            
            return {
                "device_id": device_id,
                "device_name": device.hostname or device.name,
                "success": result.get("success", False),
                "config_id": result.get("config_id"),
                "execution_time": execution_time,
                "config_size": result.get("config_size", 0),
                "git_commit_id": result.get("git_commit_id"),
                "error_message": result.get("error")
            }
        
        except Exception as e:
            execution_time = (datetime.now() - start_time).total_seconds()
            logger.error(f"设备 {device_id} 备份失败: {str(e)}")
            
            return {
                "device_id": device_id,
                "device_name": device.hostname or device.name,
                "success": False,
                "error_message": str(e),
                "execution_time": execution_time,
                "error_code": "BACKUP_ERROR"
            }


# 全局执行器实例
backup_executor = BackupExecutor()
```

**Step 5: 实现备份所有设备API**

```python
# app/routers/configurations.py
from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks, Query
from sqlalchemy.orm import Session
from typing import Optional, List
import uuid
from datetime import datetime

from app.database import get_db
from app.models.models import Device, Configuration, BackupSchedule
from app.models.backup_task import BackupTask, BackupTaskStatus
from app.schemas.backup import (
    BackupFilter, BackupTaskResponse, BackupTaskDetailResponse,
    BackupTaskListResponse, CancelTaskResponse
)
from app.services.backup_executor import backup_executor

router = APIRouter(prefix="/configurations", tags=["configurations"])

# 内存中的任务存储（用于快速查询，实际状态以数据库为准）
_backup_tasks_cache: Dict[str, BackupTask] = {}


def get_backup_task_db(task_id: str, db: Session) -> Optional[BackupTask]:
    """从数据库获取备份任务"""
    return db.query(BackupTask).filter(BackupTask.task_id == task_id).first()


@router.post("/backup-all", response_model=BackupTaskResponse)
async def backup_all_devices(
    filter_params: BackupFilter,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db)
):
    """
    备份所有设备或符合条件的设备
    - 异步执行：立即返回任务ID，后台执行备份
    - 同步执行：等待所有设备备份完成返回结果
    - 支持并发控制和失败重试
    """
    # 获取符合筛选条件的设备
    query = db.query(Device)
    
    if filter_params.filter_status:
        query = query.filter(Device.status == filter_params.filter_status)
    
    if filter_params.filter_vendor:
        query = query.filter(Device.vendor == filter_params.filter_vendor)
    
    devices = query.all()
    total = len(devices)
    
    if total == 0:
        return {
            "task_id": str(uuid.uuid4()),
            "status": BackupTaskStatus.COMPLETED,
            "total": 0,
            "completed": 0,
            "success_count": 0,
            "failed_count": 0,
            "message": "没有符合条件的设备",
            "created_at": datetime.now(),
            "progress_percentage": 100.0
        }
    
    # 创建任务记录
    task = BackupTask(
        total=total,
        filters={
            "filter_status": filter_params.filter_status,
            "filter_vendor": filter_params.filter_vendor
        },
        max_concurrent=filter_params.max_concurrent,
        timeout=filter_params.timeout,
        retry_count=filter_params.retry_count,
        notify_on_complete=1 if filter_params.notify_on_complete else 0,
        priority=filter_params.priority
    )
    db.add(task)
    db.commit()
    db.refresh(task)
    
    _backup_tasks_cache[task.task_id] = task
    
    if filter_params.async_execute:
        # 异步执行
        background_tasks.add_task(
            _execute_backup_task_async,
            task.task_id,
            [d.id for d in devices],
            filter_params
        )
        
        return {
            "task_id": task.task_id,
            "status": BackupTaskStatus.PENDING,
            "total": total,
            "completed": 0,
            "success_count": 0,
            "failed_count": 0,
            "message": f"已启动批量备份任务，共 {total} 个设备",
            "created_at": task.created_at,
            "progress_percentage": 0.0
        }
    else:
        # 同步执行
        results = await _execute_backup_task_sync(
            task.task_id,
            [d.id for d in devices],
            filter_params,
            db
        )
        
        return {
            "task_id": task.task_id,
            "status": task.status,
            "total": total,
            "completed": task.completed,
            "success_count": task.success_count,
            "failed_count": task.failed_count,
            "message": f"备份完成，成功 {task.success_count} 个，失败 {task.failed_count} 个",
            "created_at": task.created_at,
            "started_at": task.started_at,
            "completed_at": task.completed_at,
            "progress_percentage": task.progress_percentage
        }


async def _execute_backup_task_async(
    task_id: str,
    device_ids: List[int],
    filter_params: BackupFilter
):
    """异步执行备份任务"""
    from app.database import SessionLocal
    
    db = SessionLocal()
    try:
        executor = BackupExecutor(
            max_concurrent=filter_params.max_concurrent,
            timeout=filter_params.timeout
        )
        await executor.execute_backup_all(
            task_id=task_id,
            device_ids=device_ids,
            db=db,
            retry_count=filter_params.retry_count
        )
    finally:
        db.close()


async def _execute_backup_task_sync(
    task_id: str,
    device_ids: List[int],
    filter_params: BackupFilter,
    db: Session
):
    """同步执行备份任务"""
    executor = BackupExecutor(
        max_concurrent=filter_params.max_concurrent,
        timeout=filter_params.timeout
    )
    return await executor.execute_backup_all(
        task_id=task_id,
        device_ids=device_ids,
        db=db,
        retry_count=filter_params.retry_count
    )


@router.get("/backup-tasks", response_model=BackupTaskListResponse)
async def list_backup_tasks(
    page: int = Query(1, ge=1),
    page_size: int = Query(20, ge=1, le=100),
    status: Optional[str] = Query(None),
    db: Session = Depends(get_db)
):
    """获取备份任务列表"""
    query = db.query(BackupTask)
    
    if status:
        query = query.filter(BackupTask.status == status)
    
    total = query.count()
    tasks = query.order_by(BackupTask.created_at.desc()).offset(
        (page - 1) * page_size
    ).limit(page_size).all()
    
    return {
        "tasks": [task.to_dict() for task in tasks],
        "total": total,
        "page": page,
        "page_size": page_size
    }


@router.get("/backup-tasks/{task_id}", response_model=BackupTaskDetailResponse)
async def get_backup_task_status(
    task_id: str,
    db: Session = Depends(get_db)
):
    """获取备份任务状态和详情"""
    task = get_backup_task_db(task_id, db)
    
    if not task:
        raise HTTPException(status_code=404, detail="任务不存在")
    
    response = task.to_dict()
    if task.error_details:
        response["errors"] = task.error_details.get("errors", [])
    
    return response


@router.post("/backup-tasks/{task_id}/cancel", response_model=CancelTaskResponse)
async def cancel_backup_task(
    task_id: str,
    db: Session = Depends(get_db)
):
    """取消备份任务"""
    task = get_backup_task_db(task_id, db)
    
    if not task:
        raise HTTPException(status_code=404, detail="任务不存在")
    
    if task.status == BackupTaskStatus.COMPLETED:
        raise HTTPException(status_code=400, detail="任务已完成，无法取消")
    
    if task.status == BackupTaskStatus.CANCELLED:
        raise HTTPException(status_code=400, detail="任务已取消")
    
    # 标记任务为取消状态
    task.status = BackupTaskStatus.CANCELLED
    task.completed_at = datetime.now()
    db.commit()
    
    # 通知执行器取消任务
    backup_executor.cancel_task(task_id)
    
    return {"message": "任务已取消", "task_id": task_id}
```

**Step 6: 运行测试验证通过**

```bash
pytest tests/unit/test_backup_all_api.py -v
```

预期: PASS

**Step 7: 提交变更**

```bash
git add app/routers/configurations.py app/schemas/backup.py app/services/backup_executor.py tests/unit/test_backup_all_api.py
git commit -m "feat: 新增 /configurations/backup-all API，支持并发控制、任务状态查询和取消功能"
```

---

### 任务2: 前端新增备份API接口

**涉及文件:**
- 修改: `frontend/src/api/configurationApi.js`
- 新增: `frontend/src/api/backupApi.js`

**Step 1: 新增API方法**

```javascript
// frontend/src/api/backupApi.js
import request from '@/utils/request'

export const backupApi = {
  /**
   * 批量备份所有设备
   * @param {Object} params - 备份参数
   * @param {string} params.filter_status - 按状态筛选 (online/offline/maintenance)
   * @param {string} params.filter_vendor - 按厂商筛选
   * @param {boolean} params.async_execute - 是否异步执行
   * @param {boolean} params.notify_on_complete - 完成后是否通知
   * @param {string} params.priority - 任务优先级 (low/normal/high)
   * @param {number} params.max_concurrent - 最大并发数 (1-10)
   * @param {number} params.timeout - 超时时间（秒）
   * @param {number} params.retry_count - 重试次数 (0-5)
   * @returns {Promise<{task_id: string, message: string, total: number, status: string}>}
   */
  backupAll(params) {
    return request({
      url: '/configurations/backup-all',
      method: 'post',
      data: {
        filter_status: params.filter_status || null,
        filter_vendor: params.filter_vendor || null,
        async_execute: params.async_execute !== false,
        notify_on_complete: params.notify_on_complete || false,
        priority: params.priority || 'normal',
        max_concurrent: params.max_concurrent || 3,
        timeout: params.timeout || 300,
        retry_count: params.retry_count || 2,
        ...params
      }
    })
  },

  /**
   * 获取备份任务状态
   * @param {string} taskId - 任务ID
   * @returns {Promise<BackupTaskStatus>}
   */
  getBackupTaskStatus(taskId) {
    return request({
      url: `/configurations/backup-tasks/${taskId}`,
      method: 'get'
    })
  },

  /**
   * 获取所有备份任务列表
   * @param {Object} params - 查询参数
   * @param {number} params.page - 页码
   * @param {number} params.page_size - 每页数量
   * @param {string} params.status - 按状态筛选
   * @returns {Promise<{tasks: Array, total: number, page: number, page_size: number}>}
   */
  getBackupTasks(params = {}) {
    return request({
      url: '/configurations/backup-tasks',
      method: 'get',
      params: {
        page: params.page || 1,
        page_size: params.page_size || 20,
        status: params.status || null,
        ...params
      }
    })
  },

  /**
   * 取消备份任务
   * @param {string} taskId - 任务ID
   * @returns {Promise<{message: string, task_id: string}>}
   */
  cancelBackupTask(taskId) {
    return request({
      url: `/configurations/backup-tasks/${taskId}/cancel`,
      method: 'post'
    })
  },

  /**
   * 获取单个设备备份历史
   * @param {number} deviceId - 设备ID
   * @param {number} limit - 返回数量
   * @returns {Promise<Array>}
   */
  getDeviceBackupHistory(deviceId, limit = 10) {
    return request({
      url: `/configurations/devices/${deviceId}/backup-history`,
      method: 'get',
      params: { limit }
    })
  }
}
```

**Step 2: 运行前端lint检查**

```bash
cd frontend
npm run lint
```

预期: 无错误

**Step 3: 提交变更**

```bash
git add frontend/src/api/backupApi.js
git commit -m "feat: 新增批量备份 API 方法，支持任务状态查询和取消"
```

---

### 任务3: 前端实现批量备份UI组件

**涉及文件:**
- 修改: `frontend/src/views/ConfigurationManagement.vue`
- 新增: `frontend/src/components/BackupProgress.vue`
- 新增: `frontend/src/components/BackupSettingsDialog.vue`

**Step 1: 编写失败的测试**

```javascript
// frontend/tests/unit/backupProgress.spec.js
import { describe, it, expect, vi } from 'vitest'
import { mount } from '@vue/test-utils'
import BackupProgress from '@/components/BackupProgress.vue'

describe('备份进度组件测试', () => {
  it('应该正确显示进度条', () => {
    const wrapper = mount(BackupProgress, {
      props: {
        total: 10,
        completed: 5,
        status: 'running'
      }
    })
    
    expect(wrapper.find('.progress-bar').exists()).toBe(true)
    expect(wrapper.text()).toContain('50%')
  })

  it('应该在完成时显示成功状态', () => {
    const wrapper = mount(BackupProgress, {
      props: {
        total: 10,
        completed: 10,
        status: 'success'
      }
    })
    
    expect(wrapper.text()).toContain('已完成')
  })

  it('应该在失败时显示错误信息', () => {
    const wrapper = mount(BackupProgress, {
      props: {
        total: 10,
        completed: 8,
        status: 'failed',
        errors: [{ device_id: 1, device_name: 'Switch-1', error_message: '连接超时' }]
      }
    })
    
    expect(wrapper.text()).toContain('失败')
  })

  it('应该显示取消按钮当任务进行中', () => {
    const wrapper = mount(BackupProgress, {
      props: {
        total: 10,
        completed: 5,
        status: 'running'
      }
    })
    
    expect(wrapper.text()).toContain('取消任务')
  })
})
```

**Step 2: 运行测试验证失败**

```bash
npm run test:unit -- backupProgress.spec.js
```

预期: FAIL - 组件或测试文件不存在

**Step 3: 实现备份设置对话框组件**

```vue
<!-- frontend/src/components/BackupSettingsDialog.vue -->
<template>
  <el-dialog
    v-model="visible"
    title="批量备份设置"
    width="500px"
    :close-on-click-modal="false"
  >
    <el-form :model="settings" label-width="120px">
      <el-form-item label="筛选条件">
        <el-select v-model="settings.filter_status" placeholder="设备状态" clearable>
          <el-option label="在线" value="online" />
          <el-option label="离线" value="offline" />
          <el-option label="维护中" value="maintenance" />
        </el-select>
      </el-form-item>
      
      <el-form-item>
        <el-select v-model="settings.filter_vendor" placeholder="厂商" clearable>
          <el-option label="Cisco" value="Cisco" />
          <el-option label="Huawei" value="Huawei" />
          <el-option label="H3C" value="H3C" />
          <el-option label="Ruijie" value="Ruijie" />
        </el-select>
      </el-form-item>
      
      <el-form-item label="任务优先级">
        <el-radio-group v-model="settings.priority">
          <el-radio-button label="low">低</el-radio-button>
          <el-radio-button label="normal">中</el-radio-button>
          <el-radio-button label="high">高</el-radio-button>
        </el-radio-group>
      </el-form-item>
      
      <el-form-item label="最大并发数">
        <el-slider v-model="settings.max_concurrent" :min="1" :max="10" show-stops />
        <span class="slider-value">{{ settings.max_concurrent }}</span>
      </el-form-item>
      
      <el-form-item label="超时时间(秒)">
        <el-slider v-model="settings.timeout" :min="60" :max="600" :step="30" />
        <span class="slider-value">{{ settings.timeout }}s</span>
      </el-form-item>
      
      <el-form-item label="重试次数">
        <el-slider v-model="settings.retry_count" :min="0" :max="5" show-stops />
        <span class="slider-value">{{ settings.retry_count }}</span>
      </el-form-item>
      
      <el-form-item label="执行模式">
        <el-switch
          v-model="settings.async_execute"
          active-text="异步执行"
          inactive-text="同步执行"
        />
      </el-form-item>
      
      <el-form-item label="完成通知">
        <el-switch
          v-model="settings.notify_on_complete"
          active-text="开启"
          inactive-text="关闭"
        />
      </el-form-item>
    </el-form>
    
    <template #footer>
      <el-button @click="visible = false">取消</el-button>
      <el-button type="primary" @click="handleConfirm" :loading="loading">
        开始备份
      </el-button>
    </template>
  </el-dialog>
</template>

<script>
import { ref, reactive, watch } from 'vue'

export default {
  name: 'BackupSettingsDialog',
  props: {
    modelValue: {
      type: Boolean,
      default: false
    },
    loading: {
      type: Boolean,
      default: false
    }
  },
  emits: ['update:modelValue', 'confirm'],
  setup(props, { emit }) {
    const visible = ref(props.modelValue)
    
    const settings = reactive({
      filter_status: null,
      filter_vendor: null,
      priority: 'normal',
      max_concurrent: 3,
      timeout: 300,
      retry_count: 2,
      async_execute: true,
      notify_on_complete: false
    })
    
    watch(() => props.modelValue, (val) => {
      visible.value = val
    })
    
    watch(visible, (val) => {
      emit('update:modelValue', val)
    })
    
    const handleConfirm = () => {
      emit('confirm', { ...settings })
    }
    
    return {
      visible,
      settings,
      handleConfirm
    }
  }
}
</script>

<style scoped>
.slider-value {
  margin-left: 10px;
  color: #606266;
}
</style>
```

**Step 4: 实现备份进度组件（增强版）**

```vue
<!-- frontend/src/components/BackupProgress.vue -->
<template>
  <div class="backup-progress">
    <el-card class="progress-card">
      <template #header>
        <div class="card-header">
          <div class="header-left">
            <span class="title">{{ title }}</span>
            <el-tag :type="statusType" size="small">{{ statusText }}</el-tag>
            <span class="task-id" v-if="taskId">任务ID: {{ taskId }}</span>
          </div>
          <div class="header-right">
            <el-button 
              v-if="status === 'running'" 
              type="danger" 
              size="small"
              @click="handleCancel"
              :loading="cancelling"
            >
              取消任务
            </el-button>
            <el-button 
              v-if="status === 'failed' || status === 'completed'" 
              type="primary" 
              size="small"
              @click="handleRetry"
            >
              重新执行
            </el-button>
            <el-button 
              v-if="status !== 'running'" 
              size="small"
              @click="handleClose"
            >
              关闭
            </el-button>
          </div>
        </div>
      </template>
      
      <div class="progress-content">
        <!-- 进度条 -->
        <div class="progress-section">
          <div class="progress-stats">
            <div class="stat-item">
              <span class="stat-label">总设备数</span>
              <span class="stat-value">{{ total }}</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">已备份</span>
              <span class="stat-value success">{{ completed }}</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">成功</span>
              <span class="stat-value success">{{ successCount }}</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">失败</span>
              <span class="stat-value danger">{{ failedCount }}</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">成功率</span>
              <span class="stat-value">{{ successRate }}%</span>
            </div>
          </div>
          
          <el-progress 
            :percentage="progressPercentage" 
            :status="progressStatus"
            :stroke-width="12"
            :show-text="true"
          >
            <template #default="{ percentage }">
              <span class="progress-text">{{ percentage }}%</span>
            </template>
          </el-progress>
        </div>
        
        <!-- 执行时间 -->
        <div class="time-section" v-if="startedAt">
          <div class="time-item">
            <el-icon><Clock /></el-icon>
            <span>开始时间: {{ formatTime(startedAt) }}</span>
          </div>
          <div class="time-item" v-if="completedAt">
            <el-icon><Timer /></el-icon>
            <span>完成时间: {{ formatTime(completedAt) }}</span>
          </div>
          <div class="time-item" v-if="executionTime">
            <el-icon><Lightning /></el-icon>
            <span>总耗时: {{ formatDuration(executionTime) }}</span>
          </div>
        </div>
        
        <!-- 错误详情 -->
        <div v-if="errors.length > 0" class="errors-section">
          <div class="section-title">失败设备详情</div>
          <el-collapse v-model="activeErrors">
            <el-collapse-item 
              :name="`error-${index}`" 
              v-for="(error, index) in displayedErrors" 
              :key="index"
              :title="`设备: ${error.device_name || '设备 ' + error.device_id}`"
            >
              <div class="error-detail">
                <div class="error-row">
                  <span class="error-label">错误信息:</span>
                  <span class="error-message">{{ error.error_message }}</span>
                </div>
                <div class="error-row" v-if="error.error_code">
                  <span class="error-label">错误代码:</span>
                  <el-tag size="small" type="danger">{{ error.error_code }}</el-tag>
                </div>
                <div class="error-row" v-if="error.execution_time">
                  <span class="error-label">执行时间:</span>
                  <span>{{ error.execution_time }}s</span>
                </div>
              </div>
            </el-collapse-item>
          </el-collapse>
          <div class="more-errors" v-if="errors.length > 10">
            <el-button link @click="showAllErrors = !showAllErrors">
              {{ showAllErrors ? '收起' : `查看全部 ${errors.length} 个错误` }}
            </el-button>
          </div>
        </div>
      </div>
    </el-card>
  </div>
</template>

<script>
import { ref, computed, watch } from 'vue'
import { Clock, Timer, Lightning } from '@element-plus/icons-vue'
import { ElMessage, ElMessageBox } from 'element-plus'
import { backupApi } from '@/api/backupApi'

export default {
  name: 'BackupProgress',
  components: {
    Clock,
    Timer,
    Lightning
  },
  props: {
    title: {
      type: String,
      default: '批量备份进度'
    },
    taskId: {
      type: String,
      default: null
    },
    total: {
      type: Number,
      required: true
    },
    completed: {
      type: Number,
      default: 0
    },
    successCount: {
      type: Number,
      default: 0
    },
    failedCount: {
      type: Number,
      default: 0
    },
    status: {
      type: String,
      default: 'idle'
    },
    errors: {
      type: Array,
      default: () => []
    },
    startedAt: {
      type: [Date, String],
      default: null
    },
    completedAt: {
      type: [Date, String],
      default: null
    }
  },
  emits: ['cancel', 'retry', 'close'],
  setup(props, { emit }) {
    const cancelling = ref(false)
    const activeErrors = ref([])
    const showAllErrors = ref(false)
    
    const progressPercentage = computed(() => {
      if (props.total === 0) return 100
      return Math.round((props.completed / props.total) * 100)
    })
    
    const successRate = computed(() => {
      if (props.total === 0) return 100
      return Math.round((props.successCount / props.total) * 100)
    })
    
    const statusType = computed(() => {
      const types = {
        idle: 'info',
        pending: 'info',
        running: 'primary',
        completed: 'success',
        success: 'success',
        failed: 'danger',
        partial: 'warning',
        cancelled: 'info'
      }
      return types[props.status] || 'info'
    })
    
    const statusText = computed(() => {
      const texts = {
        idle: '等待开始',
        pending: '等待执行',
        running: '进行中',
        completed: '已完成',
        success: '已完成',
        failed: '全部失败',
        partial: '部分失败',
        cancelled: '已取消'
      }
      return texts[props.status] || '未知'
    })
    
    const progressStatus = computed(() => {
      if (props.status === 'success' || props.status === 'completed') return 'success'
      if (props.status === 'failed' || props.status === 'exception') return 'exception'
      return null
    })
    
    const executionTime = computed(() => {
      if (!props.startedAt) return null
      const end = props.completedAt ? new Date(props.completedAt) : new Date()
      const start = new Date(props.startedAt)
      return Math.round((end - start) / 1000)
    })
    
    const displayedErrors = computed(() => {
      if (showAllErrors.value) {
        return props.errors
      }
      return props.errors.slice(0, 10)
    })
    
    const handleCancel = async () => {
      try {
        await ElMessageBox.confirm(
          '确定要取消当前备份任务吗？已完成的设备备份将保留。',
          '取消备份任务',
          {
            confirmButtonText: '确定取消',
            cancelButtonText: '继续备份',
            type: 'warning'
          }
        )
        
        cancelling.value = true
        if (props.taskId) {
          await backupApi.cancelBackupTask(props.taskId)
        }
        emit('cancel')
        ElMessage.success('任务已取消')
      } catch (error) {
        if (error !== 'cancel') {
          ElMessage.error('取消任务失败')
        }
      } finally {
        cancelling.value = false
      }
    }
    
    const handleRetry = () => {
      emit('retry')
    }
    
    const handleClose = () => {
      emit('close')
    }
    
    const formatTime = (time) => {
      if (!time) return '-'
      const date = new Date(time)
      return date.toLocaleString('zh-CN')
    }
    
    const formatDuration = (seconds) => {
      if (!seconds) return '-'
      const hours = Math.floor(seconds / 3600)
      const minutes = Math.floor((seconds % 3600) / 60)
      const secs = Math.floor(seconds % 60)
      
      if (hours > 0) {
        return `${hours}小时${minutes}分${secs}秒`
      }
      if (minutes > 0) {
        return `${minutes}分${secs}秒`
      }
      return `${secs}秒`
    }
    
    return {
      cancelling,
      activeErrors,
      showAllErrors,
      progressPercentage,
      successRate,
      statusType,
      statusText,
      progressStatus,
      executionTime,
      displayedErrors,
      handleCancel,
      handleRetry,
      handleClose,
      formatTime,
      formatDuration
    }
  }
}
</script>

<style scoped>
.backup-progress {
  margin: 10px 0;
}

.progress-card {
  width: 100%;
}

.card-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.header-left {
  display: flex;
  align-items: center;
  gap: 10px;
}

.header-left .title {
  font-weight: bold;
}

.task-id {
  font-size: 12px;
  color: #909399;
}

.progress-content {
  padding: 10px 0;
}

.progress-section {
  margin-bottom: 15px;
}

.progress-stats {
  display: flex;
  justify-content: space-between;
  margin-bottom: 10px;
  padding: 10px;
  background: #f5f7fa;
  border-radius: 4px;
}

.stat-item {
  text-align: center;
}

.stat-label {
  display: block;
  font-size: 12px;
  color: #909399;
}

.stat-value {
  font-size: 18px;
  font-weight: bold;
}

.stat-value.success {
  color: #67c23a;
}

.stat-value.danger {
  color: #f56c6c;
}

.progress-text {
  font-weight: bold;
}

.time-section {
  display: flex;
  gap: 20px;
  margin-bottom: 15px;
  color: #606266;
}

.time-item {
  display: flex;
  align-items: center;
  gap: 5px;
}

.errors-section {
  margin-top: 10px;
}

.section-title {
  font-weight: bold;
  margin-bottom: 10px;
  color: #606266;
}

.error-detail {
  padding: 10px;
  background: #fdf6ec;
  border-radius: 4px;
}

.error-row {
  margin-bottom: 5px;
}

.error-label {
  font-weight: bold;
  margin-right: 10px;
}

.error-message {
  color: #f56c6c;
}

.more-errors {
  text-align: center;
  padding: 10px;
}
</style>
```

**Step 5: 在配置管理页面集成备份功能**

```javascript
// 在 ConfigurationManagement.vue 中
import { backupApi } from '@/api/backupApi'
import BackupProgress from '@/components/BackupProgress.vue'
import BackupSettingsDialog from '@/components/BackupSettingsDialog.vue'

export default {
  components: {
    BackupProgress,
    BackupSettingsDialog
  },
  data() {
    return {
      // ... 现有数据
      backupSettingsVisible: false,
      backupProgress: {
        visible: false,
        total: 0,
        completed: 0,
        successCount: 0,
        failedCount: 0,
        status: 'idle',
        errors: [],
        taskId: null,
        startedAt: null,
        completedAt: null,
        pollingTimer: null
      }
    }
  },
  methods: {
    // 显示备份设置对话框
    showBackupSettings() {
      this.backupSettingsVisible = true
    },
    
    // 开始备份
    async startBackup(settings) {
      this.backupSettingsVisible = false
      
      try {
        this.resetBackupProgress()
        this.backupProgress.visible = true
        this.backupProgress.status = 'running'
        this.backupProgress.startedAt = new Date()
        
        const response = await backupApi.backupAll(settings)
        
        this.backupProgress.taskId = response.task_id
        this.backupProgress.total = response.total
        
        if (settings.async_execute) {
          // 异步执行，开始轮询
          this.startPolling()
          this.$message.success(`备份任务已启动，共 ${response.total} 个设备`)
        } else {
          // 同步执行，直接显示结果
          this.backupProgress.completed = response.total
          this.backupProgress.status = response.failed_count > 0 ? 'partial' : 'completed'
          this.backupProgress.completedAt = new Date()
        }
        
      } catch (error) {
        console.error('启动备份失败:', error)
        this.$message.error('启动备份失败: ' + (error.message || '未知错误'))
        this.backupProgress.status = 'failed'
      }
    },
    
    // 重置备份进度
    resetBackupProgress() {
      this.backupProgress = {
        visible: true,
        total: 0,
        completed: 0,
        successCount: 0,
        failedCount: 0,
        status: 'idle',
        errors: [],
        taskId: null,
        startedAt: null,
        completedAt: null,
        pollingTimer: null
      }
    },
    
    // 开始轮询任务状态
    startPolling() {
      this.backupProgress.pollingTimer = setInterval(async () => {
        await this.checkBackupStatus()
      }, 2000) // 每2秒查询一次
    },
    
    // 查询备份状态
    async checkBackupStatus() {
      try {
        const response = await backupApi.getBackupTaskStatus(this.backupProgress.taskId)
        
        this.backupProgress.completed = response.completed
        this.backupProgress.successCount = response.success_count
        this.backupProgress.failedCount = response.failed_count
        this.backupProgress.status = response.status
        this.backupProgress.startedAt = response.started_at
        this.backupProgress.completedAt = response.completed_at
        this.backupProgress.errors = response.errors || []
        
        // 任务完成或失败时停止轮询
        if (['completed', 'failed', 'cancelled'].includes(response.status)) {
          clearInterval(this.backupProgress.pollingTimer)
          this.backupProgress.pollingTimer = null
          
          if (response.status === 'completed') {
            this.$message.success(`备份完成！成功: ${response.success_count}, 失败: ${response.failed_count}`)
          } else if (response.status === 'failed') {
            this.$message.error('备份任务失败')
          } else if (response.status === 'cancelled') {
            this.$message.info('备份任务已取消')
          }
        }
        
      } catch (error) {
        console.error('查询备份状态失败:', error)
      }
    },
    
    // 取消备份
    async handleBackupCancel() {
      if (this.backupProgress.pollingTimer) {
        clearInterval(this.backupProgress.pollingTimer)
        this.backupProgress.pollingTimer = null
      }
    },
    
    // 重新执行备份
    handleBackupRetry() {
      this.showBackupSettings()
    },
    
    // 关闭备份进度
    handleBackupClose() {
      this.backupProgress.visible = false
      if (this.backupProgress.pollingTimer) {
        clearInterval(this.backupProgress.pollingTimer)
        this.backupProgress.pollingTimer = null
      }
    }
  },
  beforeUnmount() {
    // 清理轮询定时器
    if (this.backupProgress.pollingTimer) {
      clearInterval(this.backupProgress.pollingTimer)
    }
  }
}
```

**Step 6: 运行测试验证通过**

```bash
npm run test:unit -- backupProgress.spec.js
```

预期: PASS

**Step 7: 提交变更**

```bash
git add frontend/src/components/BackupProgress.vue frontend/src/components/BackupSettingsDialog.vue frontend/src/views/ConfigurationManagement.vue
git commit -m "feat: 实现批量备份UI组件，支持设置对话框、进度展示、取消和重试功能"
```

---

### 任务4: 集成测试

**涉及文件:**
- 修改: `tests/integration/test_backup_flow.py`

**Step 1: 编写集成测试**

```python
# tests/integration/test_backup_flow.py
import pytest
import asyncio
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from unittest.mock import AsyncMock, patch, MagicMock

from app.main import app
from app.models.backup_task import BackupTask, BackupTaskStatus


class TestBackupIntegration:
    """备份流程集成测试"""

    def test_full_backup_workflow(self, test_db, test_client):
        """测试完整的备份工作流程"""
        # 1. 创建设备
        device_data = {
            "name": "Test-Switch",
            "ip": "192.168.100.1",
            "vendor": "Cisco",
            "username": "admin",
            "password": "secret",
            "status": "online"
        }
        
        response = test_client.post("/devices/", json=device_data)
        assert response.status_code == 200
        device_id = response.json()["id"]

        # 2. 启动全量备份
        backup_request = {
            "filter_status": None,
            "filter_vendor": None,
            "async_execute": True,
            "notify_on_complete": False,
            "max_concurrent": 3,
            "retry_count": 2
        }
        
        response = test_client.post("/configurations/backup-all", json=backup_request)
        assert response.status_code == 200
        task_id = response.json()["task_id"]
        assert task_id is not None
        assert response.json()["total"] >= 1

        # 3. 查询任务状态
        response = test_client.get(f"/configurations/backup-tasks/{task_id}")
        assert response.status_code == 200
        task = response.json()
        assert task["task_id"] == task_id
        assert "status" in task

    def test_backup_with_device_filter(self, test_db, test_client):
        """测试带筛选条件的备份"""
        # 创建设备（部分在线，部分离线）
        for i in range(5):
            test_client.post("/devices/", json={
                "name": f"Switch-{i}",
                "ip": f"192.168.1.{i}",
                "vendor": "Cisco",
                "status": "online" if i % 2 == 0 else "offline"
            })

        # 只备份在线设备
        backup_request = {
            "filter_status": "online",
            "async_execute": False,
            "notify_on_complete": False
        }
        
        with patch('app.services.backup_executor.BackupExecutor._execute_single_backup') as mock_backup:
            mock_backup.return_value = {
                "device_id": 1,
                "success": True,
                "config_id": 100
            }
            
            response = test_client.post("/configurations/backup-all", json=backup_request)
            assert response.status_code == 200
            result = response.json()
            assert result["total"] == 3  # 3个在线设备

    def test_cancel_backup_task(self, test_db, test_client):
        """测试取消备份任务"""
        # 1. 创建设备
        test_client.post("/devices/", json={
            "name": "Test-Switch",
            "ip": "192.168.100.1",
            "vendor": "Cisco",
            "status": "online"
        })

        # 2. 启动异步备份
        response = test_client.post("/configurations/backup-all", json={
            "async_execute": True
        })
        task_id = response.json()["task_id"]

        # 3. 取消任务
        response = test_client.post(f"/configurations/backup-tasks/{task_id}/cancel")
        assert response.status_code == 200
        assert response.json()["task_id"] == task_id

        # 4. 验证任务状态
        response = test_client.get(f"/configurations/backup-tasks/{task_id}")
        assert response.json()["status"] == "cancelled"

    def test_backup_task_list(self, test_db, test_client):
        """测试获取备份任务列表"""
        # 创建多个任务
        for i in range(3):
            test_client.post("/configurations/backup-all", json={
                "async_execute": True
            })

        # 获取任务列表
        response = test_client.get("/configurations/backup-tasks?page=1&page_size=10")
        assert response.status_code == 200
        result = response.json()
        assert "tasks" in result
        assert "total" in result
        assert result["total"] >= 3

    def test_backup_with_retry(self, test_db, test_client):
        """测试备份失败重试"""
        # 创建设备
        test_client.post("/devices/", json={
            "name": "Test-Switch",
            "ip": "192.168.100.1",
            "vendor": "Cisco",
            "status": "online"
        })

        call_count = 0
        
        async def mock_backup(*args, **kwargs):
            nonlocal call_count
            call_count += 1
            if call_count <= 2:
                raise Exception("临时失败")
            return {"success": True, "config_id": 100}

        with patch('app.services.backup_executor.BackupExecutor._execute_single_backup', side_effect=mock_backup):
            response = test_client.post("/configurations/backup-all", json={
                "async_execute": False,
                "retry_count": 3
            })
            
            assert response.status_code == 200
            # 验证被调用了多次（重试）
            assert call_count >= 2

    def test_concurrent_backup_control(self, test_db, test_client):
        """测试并发控制"""
        # 创建多个设备
        for i in range(10):
            test_client.post("/devices/", json={
                "name": f"Switch-{i}",
                "ip": f"192.168.1.{i}",
                "vendor": "Cisco",
                "status": "online"
            })

        # 使用低并发数
        response = test_client.post("/configurations/backup-all", json={
            "async_execute": False,
            "max_concurrent": 2,  # 限制并发数为2
            "retry_count": 0
        })
        
        assert response.status_code == 200
        result = response.json()
        assert result["total"] == 10


class TestBackupErrorHandling:
    """备份错误处理测试"""

    def test_backup_nonexistent_device(self, test_db, test_client):
        """测试备份不存在的设备"""
        response = test_client.post("/configurations/backup-all", json={
            "filter_status": "nonexistent_status",
            "async_execute": False
        })
        
        assert response.status_code == 200
        assert response.json()["total"] == 0
        assert "没有符合条件的设备" in response.json()["message"]

    def test_get_nonexistent_task(self, test_db, test_client):
        """测试获取不存在的任务"""
        response = test_client.get("/configurations/backup-tasks/nonexistent-task-id")
        assert response.status_code == 404

    def test_cancel_completed_task(self, test_db, test_client):
        """测试取消已完成的任务"""
        # 创建设备并执行同步备份
        test_client.post("/devices/", json={
            "name": "Test-Switch",
            "ip": "192.168.100.1",
            "vendor": "Cisco",
            "status": "online"
        })

        with patch('app.services.backup_executor.BackupExecutor._execute_single_backup') as mock_backup:
            mock_backup.return_value = {"success": True, "config_id": 100}
            
            response = test_client.post("/configurations/backup-all", json={
                "async_execute": False
            })
            task_id = response.json()["task_id"]

            # 尝试取消已完成的任务
            response = test_client.post(f"/configurations/backup-tasks/{task_id}/cancel")
            assert response.status_code == 400
            assert "任务已完成" in response.json()["detail"]
```

**Step 2: 运行集成测试**

```bash
pytest tests/integration/test_backup_flow.py -v
```

预期: PASS

**Step 3: 提交变更**

```bash
git add tests/integration/test_backup_flow.py
git commit -m "test: 添加批量备份集成测试，覆盖任务取消、重试、并发控制等场景"
```

---

## 验收标准

1. [x] `/configurations/backup-all` API 支持异步和同步两种模式
2. [x] API 支持按状态、厂商筛选设备
3. [x] API 支持并发控制参数（max_concurrent）
4. [x] API 支持失败重试（retry_count）
5. [x] 任务状态持久化到数据库
6. [x] 支持任务状态查询接口 `/configurations/backup-tasks/{task_id}`
7. [x] 支持任务列表查询接口 `/configurations/backup-tasks`
8. [x] 支持取消任务接口 `/configurations/backup-tasks/{task_id}/cancel`
9. [x] 前端显示"备份所有设备"按钮
10. [x] 前端支持备份设置对话框（筛选、并发、重试等）
11. [x] 备份进度正确显示并实时更新
12. [x] 失败设备显示错误原因和错误代码
13. [x] 支持取消正在进行的备份任务
14. [x] 支持重新执行备份任务
15. [x] 所有单元测试和集成测试通过
16. [x] 前端lint检查通过

---

## 相关文档

- 原始需求: `docs/功能需求/前端/配置管理模块问题分析与优化方案.md`
- 原始评审: `docs/功能需求/前端/配置管理模块问题分析与优化方案-评审文档.md`
- Phase 1评审: `docs/功能需求/前端/plans/Phase1-修复设备列表显示问题/Phase1-修复设备列表显示问题-评审文档.md`
- 当前评审: `docs/功能需求/前端/plans/Phase2-批量备份功能/Phase2-批量备份功能-评审文档.md`
- 备份调度器: `app/services/backup_scheduler.py`

---

## 改进记录

### 根据评审文档的改进

1. **任务状态持久化** (任务0)
   - 新增 `backup_tasks` 数据库表
   - 支持任务状态、进度、错误详情的持久化
   - 避免服务重启导致任务丢失

2. **并发控制** (任务1)
   - 使用 `asyncio.Semaphore` 实现并发控制
   - 支持通过 `max_concurrent` 参数配置并发数
   - 默认并发数为3，最大支持10

3. **失败重试机制** (任务1)
   - 支持通过 `retry_count` 参数配置重试次数
   - 使用指数退避策略等待重试
   - 默认重试2次，最大支持5次

4. **取消任务功能** (任务1)
   - 新增 `POST /configurations/backup-tasks/{task_id}/cancel` 接口
   - 前端支持取消按钮和确认对话框
   - 取消后保留已完成的备份结果

5. **增强的Schema设计** (任务1)
   - 新增 `BackupPriority` 优先级枚举
   - 新增 `BackupTaskStatus` 状态枚举
   - 支持参数验证（如状态值验证）

6. **增强的前端组件** (任务3)
   - 新增 `BackupSettingsDialog` 设置对话框
   - 支持配置筛选、并发、超时、重试等参数
   - `BackupProgress` 组件增加取消、重试、关闭功能
   - 显示执行时间、成功率等统计信息

7. **完善的测试覆盖** (任务4)
   - 单元测试覆盖模型、API、执行器
   - 集成测试覆盖完整工作流程
   - 测试覆盖取消、重试、并发控制等场景
