# Phase 3: 备份计划监控面板

> **For Claude:** REQUIRED SUB-SKILL: 使用 superpowers:subagent-driven-development 或 superpowers:executing-plans 实施此计划。

**目标:** 实现备份计划的监控面板功能，包括数据库表设计、后端调度器日志记录、监控统计API和前端可视化面板。

**架构说明:**
- 数据库新增 `backup_execution_logs` 表记录每次备份执行详情
- 后端调度器在执行备份时记录执行日志
- 后端提供监控统计API，返回成功率、执行时间趋势等数据
- 前端实现监控面板组件，展示实时状态和历史统计

**技术栈:**
- 后端: FastAPI, SQLAlchemy, Pydantic, APScheduler
- 前端: Vue 3, Element Plus, ECharts, Axios

---

## 任务拆解

### 任务1: 数据库设计并创建 `backup_execution_logs` 表

**涉及文件:**
- 修改: `app/models/models.py`
- 新增: `tests/unit/test_backup_execution_logs.py`

**Step 1: 编写失败的测试**

```python
# tests/unit/test_backup_execution_logs.py
import pytest
from sqlalchemy import create_engine, inspect
from app.models.models import Base

def test_backup_execution_logs_table_exists():
    """测试 backup_execution_logs 表是否存在"""
    engine = create_engine("sqlite:///./test.db")
    inspector = inspect(engine)
    
    tables = inspector.get_table_names()
    assert "backup_execution_logs" in tables

def test_backup_execution_logs_columns():
    """测试 backup_execution_logs 表的列定义"""
    from app.models.models import BackupExecutionLog
    
    # 验证模型属性
    log = BackupExecutionLog(
        task_id="test-task-001",
        device_id=1,
        schedule_id=1,
        status="success",
        execution_time=5.5,
        config_id=100
    )
    
    assert log.task_id == "test-task-001"
    assert log.device_id == 1
    assert log.schedule_id == 1
    assert log.status == "success"
    assert log.execution_time == 5.5
    assert log.config_id == 100

def test_backup_execution_log_crud():
    """测试 backup_execution_log 的CRUD操作"""
    from app.models.models import BackupExecutionLog
    from app.database import SessionLocal
    
    db = SessionLocal()
    
    # Create
    log = BackupExecutionLog(
        task_id="crud-test-001",
        device_id=1,
        schedule_id=1,
        status="success",
        execution_time=3.2,
        config_id=50
    )
    db.add(log)
    db.commit()
    
    # Read
    saved_log = db.query(BackupExecutionLog).filter_by(task_id="crud-test-001").first()
    assert saved_log is not None
    assert saved_log.status == "success"
    
    # Update
    saved_log.status = "failed"
    saved_log.error_message = "Connection timeout"
    db.commit()
    
    updated_log = db.query(BackupExecutionLog).filter_by(task_id="crud-test-001").first()
    assert updated_log.status == "failed"
    assert updated_log.error_message == "Connection timeout"
    
    # Delete
    db.delete(updated_log)
    db.commit()
    
    deleted_log = db.query(BackupExecutionLog).filter_by(task_id="crud-test-001").first()
    assert deleted_log is None
    
    db.close()
```

**Step 2: 运行测试验证失败**

```bash
cd d:\BaiduSyncdisk\5.code\netdevops\switch_manage
pytest tests/unit/test_backup_execution_logs.py -v
```

预期: FAIL - `BackupExecutionLog` 模型不存在

**Step 3: 定义数据模型**

```python
# 在 app/models/models.py 中添加

from sqlalchemy import Column, Integer, String, DateTime, Float, Text, Boolean, ForeignKey, Index
from sqlalchemy.orm import relationship
from datetime import datetime
import uuid

class BackupExecutionLog(Base):
    """
    备份执行日志表
    记录每次备份任务的执行详情
    """
    __tablename__ = "backup_execution_logs"
    
    id = Column(Integer, primary_key=True, index=True)
    task_id = Column(String(50), index=True, nullable=False, comment="任务ID")
    device_id = Column(Integer, ForeignKey("devices.id"), nullable=False, comment="设备ID")
    schedule_id = Column(Integer, ForeignKey("backup_schedules.id"), nullable=True, comment="备份计划ID")
    
    status = Column(String(20), nullable=False, comment="执行状态: success, failed, timeout, cancelled")
    execution_time = Column(Float, comment="执行耗时(秒)")
    
    # 备份结果
    config_id = Column(Integer, ForeignKey("configurations.id"), nullable=True, comment="成功备份的配置ID")
    error_message = Column(Text, nullable=True, comment="错误信息")
    error_details = Column(Text, nullable=True, comment="错误详情堆栈")
    
    # 执行上下文
    started_at = Column(DateTime, comment="开始时间")
    completed_at = Column(DateTime, comment="完成时间")
    
    # 统计信息
    config_size = Column(Integer, nullable=True, comment="配置大小(bytes)")
    git_commit_id = Column(String(40), nullable=True, comment="Git提交ID")
    
    created_at = Column(DateTime, default=datetime.now, comment="创建时间")
    
    # 索引
    __table_args__ = (
        Index("idx_backup_log_device_time", "device_id", "created_at"),
        Index("idx_backup_log_status", "status"),
        Index("idx_backup_log_schedule", "schedule_id", "created_at"),
    )
    
    def __repr__(self):
        return f"<BackupExecutionLog(id={self.id}, task_id={self.task_id}, device_id={self.device_id}, status={self.status})>"
    
    def to_dict(self):
        """转换为字典"""
        return {
            "id": self.id,
            "task_id": self.task_id,
            "device_id": self.device_id,
            "schedule_id": self.schedule_id,
            "status": self.status,
            "execution_time": self.execution_time,
            "config_id": self.config_id,
            "error_message": self.error_message,
            "started_at": self.started_at.isoformat() if self.started_at else None,
            "completed_at": self.completed_at.isoformat() if self.completed_at else None,
            "config_size": self.config_size,
            "git_commit_id": self.git_commit_id,
            "created_at": self.created_at.isoformat() if self.created_at else None
        }
```

**Step 4: 运行数据库迁移**

```bash
# 创建迁移脚本或直接更新数据库
alembic revision --autogenerate -m "Add backup_execution_logs table"
alembic upgrade head
```

或者使用SQL直接创建（开发环境）:

```sql
-- 在数据库中执行
CREATE TABLE backup_execution_logs (
    id SERIAL PRIMARY KEY,
    task_id VARCHAR(50) NOT NULL,
    device_id INTEGER NOT NULL REFERENCES devices(id),
    schedule_id INTEGER REFERENCES backup_schedules(id),
    status VARCHAR(20) NOT NULL,
    execution_time FLOAT,
    config_id INTEGER REFERENCES configurations(id),
    error_message TEXT,
    error_details TEXT,
    started_at TIMESTAMP,
    completed_at TIMESTAMP,
    config_size INTEGER,
    git_commit_id VARCHAR(40),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 创建索引
CREATE INDEX idx_backup_log_task ON backup_execution_logs(task_id);
CREATE INDEX idx_backup_log_device_time ON backup_execution_logs(device_id, created_at);
CREATE INDEX idx_backup_log_status ON backup_execution_logs(status);
CREATE INDEX idx_backup_log_schedule ON backup_execution_logs(schedule_id, created_at);
```

**Step 5: 运行测试验证通过**

```bash
pytest tests/unit/test_backup_execution_logs.py -v
```

预期: PASS

**Step 6: 提交变更**

```bash
git add app/models/models.py tests/unit/test_backup_execution_logs.py
git commit -m "feat: 新增 backup_execution_logs 数据模型"
```

---

### 任务2: 后端调度器记录执行日志

**涉及文件:**
- 修改: `app/services/backup_scheduler.py`
- 新增: `tests/unit/test_backup_scheduler_logging.py`

**Step 1: 编写失败的测试**

```python
# tests/unit/test_backup_scheduler_logging.py
import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from datetime import datetime
from app.services.backup_scheduler import BackupSchedulerService
from app.models.models import BackupExecutionLog

class TestBackupSchedulerLogging:
    """测试调度器日志记录功能"""

    @pytest.mark.asyncio
    async def test_execution_log_is_persisted(self):
        """测试备份执行日志正确持久化"""
        mock_db = MagicMock()
        
        scheduler = BackupSchedulerService()
        
        with patch('app.services.backup_scheduler.collect_config_from_device',
                   new_callable=AsyncMock) as mock_collect:
            mock_collect.return_value = {
                "success": True,
                "config_id": 100,
                "git_commit_id": "abc123def456",
                "execution_time": 5.5
            }
            
            await scheduler._execute_backup(
                device_id=1,
                schedule_id=1,
                db=mock_db
            )
            
            # 验证日志被添加
            mock_db.add.assert_called()
            # 验证提交
            mock_db.commit.assert_called()

    @pytest.mark.asyncio
    async def test_failed_execution_log_contains_error(self):
        """测试失败执行日志包含错误信息"""
        mock_db = MagicMock()
        
        scheduler = BackupSchedulerService()
        
        with patch('app.services.backup_scheduler.collect_config_from_device',
                   new_callable=AsyncMock) as mock_collect:
            mock_collect.side_effect = Exception("Connection timeout")
            
            await scheduler._execute_backup(
                device_id=1,
                schedule_id=1,
                db=mock_db
            )
            
            # 验证添加了日志
            added_log = mock_db.add.call_args[0][0]
            assert isinstance(added_log, BackupExecutionLog)
            assert added_log.status == "failed"
            assert "Connection timeout" in added_log.error_message

    @pytest.mark.asyncio
    async def test_execution_time_is_recorded(self):
        """测试执行时间被记录"""
        mock_db = MagicMock()
        
        scheduler = BackupSchedulerService()
        
        with patch('app.services.backup_scheduler.collect_config_from_device',
                   new_callable=AsyncMock) as mock_collect:
            mock_collect.return_value = {
                "success": True,
                "config_id": 100,
                "git_commit_id": "abc123",
                "execution_time": 3.5
            }
            
            await scheduler._execute_backup(
                device_id=1,
                schedule_id=1,
                db=mock_db
            )
            
            added_log = mock_db.add.call_args[0][0]
            assert added_log.execution_time == 3.5
```

**Step 2: 运行测试验证失败**

```bash
pytest tests/unit/test_backup_scheduler_logging.py -v
```

预期: FAIL - 调度器还没有实现日志记录

**Step 3: 修改调度器添加日志记录功能**

```python
# 在 app/services/backup_scheduler.py 中修改和添加

from app.models.models import BackupExecutionLog, Device
from datetime import datetime
import uuid
import asyncio

class BackupSchedulerService:
    """
    备份调度器服务类
    管理设备配置的自动备份任务
    """
    
    def __init__(self):
        self.scheduler = BackgroundScheduler()
        self.scheduler.start()
        logger.info("Backup scheduler initialized")
    
    async def _execute_backup(self, device_id: int, schedule_id: int = None, db=None):
        """
        执行单个设备的备份
        
        Args:
            device_id: 设备ID
            schedule_id: 备份计划ID（可选）
            db: 数据库会话
        """
        task_id = str(uuid.uuid4())
        device = db.query(Device).filter(Device.id == device_id).first()
        
        if not device:
            logger.error(f"Device {device_id} not found")
            return {"success": False, "error": "Device not found"}
        
        # 创建执行日志
        log = BackupExecutionLog(
            task_id=task_id,
            device_id=device_id,
            schedule_id=schedule_id,
            status="running",
            started_at=datetime.now()
        )
        db.add(log)
        db.commit()
        
        start_time = datetime.now()
        error_message = None
        error_details = None
        config_id = None
        git_commit_id = None
        config_size = None
        success = False
        
        try:
            # 执行配置采集
            from app.services.config_collector import collect_config_from_device
            result = await collect_config_from_device(device)
            
            execution_time = (datetime.now() - start_time).total_seconds()
            
            if result.get("success"):
                success = True
                config_id = result.get("config_id")
                git_commit_id = result.get("git_commit_id")
                config_size = result.get("config_size", 0)
                
                logger.info(f"Backup completed for device {device_id}: {device.hostname}")
                
            else:
                error_message = result.get("error", "Unknown error")
                logger.error(f"Backup failed for device {device_id}: {error_message}")
            
            # 更新日志状态
            log.status = "success" if success else "failed"
            log.execution_time = execution_time
            log.config_id = config_id
            log.error_message = error_message
            log.git_commit_id = git_commit_id
            log.config_size = config_size
            
        except Exception as e:
            execution_time = (datetime.now() - start_time).total_seconds()
            error_message = str(e)
            error_details = traceback.format_exc()
            
            log.status = "failed"
            log.execution_time = execution_time
            log.error_message = error_message
            log.error_details = error_details
            
            logger.exception(f"Backup error for device {device_id}: {e}")
        
        finally:
            log.completed_at = datetime.now()
            db.commit()
        
        return {
            "success": success,
            "config_id": config_id,
            "git_commit_id": git_commit_id,
            "execution_time": execution_time,
            "error": error_message
        }
    
    async def _execute_backup_all(self, device_ids: list, schedule_id: int = None, db=None):
        """
        执行多个设备的批量备份
        
        Args:
            device_ids: 设备ID列表
            schedule_id: 备份计划ID（可选）
            db: 数据库会话
        """
        task_id = str(uuid.uuid4())
        results = []
        
        semaphore = asyncio.Semaphore(self.max_concurrent_jobs if hasattr(self, 'max_concurrent_jobs') else 3)
        
        async def execute_with_limit(device_id):
            async with semaphore:
                result = await self._execute_backup(device_id, schedule_id, db)
                return {
                    "device_id": device_id,
                    **result
                }
        
        tasks = [execute_with_limit(device_id) for device_id in device_ids]
        results = await asyncio.gather(*tasks)
        
        return results
```

**Step 4: 运行测试验证通过**

```bash
pytest tests/unit/test_backup_scheduler_logging.py -v
```

预期: PASS

**Step 5: 提交变更**

```bash
git add app/services/backup_scheduler.py tests/unit/test_backup_scheduler_logging.py
git commit -m "feat: 调度器添加执行日志记录功能"
```

---

### 任务3: 后端新增监控统计API

**涉及文件:**
- 修改: `app/routers/monitoring.py` (新建)
- 新增: `app/schemas/monitoring.py`
- 新增: `tests/unit/test_monitoring_api.py`

**Step 1: 编写失败的测试**

```python
# tests/unit/test_monitoring_api.py
import pytest
from fastapi.testclient import TestClient
from app.main import app

def test_get_backup_statistics():
    """测试获取备份统计信息"""
    client = TestClient(app)
    
    response = client.get("/monitoring/backup-statistics")
    
    assert response.status_code == 200
    data = response.json()
    assert "total_executions" in data
    assert "success_rate" in data
    assert "average_execution_time" in data

def test_get_device_backup_status():
    """测试获取设备备份状态"""
    client = TestClient(app)
    
    response = client.get("/monitoring/device-backup-status")
    
    assert response.status_code == 200
    data = response.json()
    assert isinstance(data, list)

def test_get_recent_executions():
    """测试获取最近执行记录"""
    client = TestClient(app)
    
    response = client.get("/monitoring/recent-executions?limit=10")
    
    assert response.status_code == 200
    data = response.json()
    assert len(data) <= 10

def test_get_execution_trend():
    """测试获取执行趋势数据"""
    client = TestClient(app)
    
    response = client.get("/monitoring/execution-trend?days=7")
    
    assert response.status_code == 200
    data = response.json()
    assert "dates" in data
    assert "success_counts" in data
    assert "failure_counts" in data
```

**Step 2: 运行测试验证失败**

```bash
pytest tests/unit/test_monitoring_api.py -v
```

预期: FAIL - 监控API端点不存在

**Step 3: 定义监控Schema**

```python
# app/schemas/monitoring.py
from pydantic import BaseModel
from typing import Optional, List, Dict, Any
from datetime import datetime
from enum import Enum

class BackupStatus(str, Enum):
    SUCCESS = "success"
    FAILED = "failed"
    TIMEOUT = "timeout"
    CANCELLED = "cancelled"

class BackupStatistics(BaseModel):
    """备份统计信息"""
    total_executions: int
    success_count: int
    failed_count: int
    success_rate: float
    average_execution_time: float
    total_config_size: int
    device_count: int
    schedule_count: int

class DeviceBackupStatus(BaseModel):
    """设备备份状态"""
    device_id: int
    device_name: str
    last_backup_status: Optional[str]
    last_backup_time: Optional[datetime]
    total_backups: int
    success_rate: float

class ExecutionLogResponse(BaseModel):
    """执行日志响应"""
    id: int
    task_id: str
    device_id: int
    device_name: str
    status: str
    execution_time: Optional[float]
    started_at: Optional[datetime]
    completed_at: Optional[datetime]
    error_message: Optional[str]

class ExecutionTrend(BaseModel):
    """执行趋势数据"""
    dates: List[str]
    success_counts: List[int]
    failure_counts: List[int]
    average_times: List[float]

class DailyStatistics(BaseModel):
    """每日统计"""
    date: str
    total: int
    success: int
    failed: int
    avg_execution_time: float
```

**Step 4: 实现监控API**

```python
# app/routers/monitoring.py
from fastapi import APIRouter, Depends, Query
from sqlalchemy.orm import Session
from sqlalchemy import func, desc
from typing import Optional, List
from datetime import datetime, timedelta

from app.database import get_db
from app.models.models import (
    BackupExecutionLog, Device, BackupSchedule, Configuration
)
from app.schemas.monitoring import (
    BackupStatistics, DeviceBackupStatus, ExecutionLogResponse,
    ExecutionTrend, DailyStatistics
)

router = APIRouter(prefix="/monitoring", tags=["monitoring"])

@router.get("/backup-statistics", response_model=BackupStatistics)
async def get_backup_statistics(
    days: Optional[int] = Query(30, description="统计天数"),
    db: Session = Depends(get_db)
):
    """
    获取备份统计信息
    - 总执行次数
    - 成功率
    - 平均执行时间
    - 设备数量
    - 计划数量
    """
    start_date = datetime.now() - timedelta(days=days)
    
    # 总执行次数
    total_executions = db.query(func.count(BackupExecutionLog.id)).filter(
        BackupExecutionLog.created_at >= start_date
    ).scalar()
    
    # 成功次数
    success_count = db.query(func.count(BackupExecutionLog.id)).filter(
        BackupExecutionLog.created_at >= start_date,
        BackupExecutionLog.status == "success"
    ).scalar()
    
    # 失败次数
    failed_count = db.query(func.count(BackupExecutionLog.id)).filter(
        BackupExecutionLog.created_at >= start_date,
        BackupExecutionLog.status == "failed"
    ).scalar()
    
    # 平均执行时间
    avg_time = db.query(func.avg(BackupExecutionLog.execution_time)).filter(
        BackupExecutionLog.created_at >= start_date,
        BackupExecutionLog.execution_time.isnot(None)
    ).scalar() or 0.0
    
    # 总配置大小
    total_config_size = db.query(func.sum(BackupExecutionLog.config_size)).filter(
        BackupExecutionLog.created_at >= start_date
    ).scalar() or 0
    
    # 设备数量
    device_count = db.query(func.count(Device.id)).scalar()
    
    # 计划数量
    schedule_count = db.query(func.count(BackupSchedule.id)).filter(
        BackupSchedule.is_active == True
    ).scalar()
    
    success_rate = (success_count / total_executions * 100) if total_executions > 0 else 0.0
    
    return {
        "total_executions": total_executions,
        "success_count": success_count,
        "failed_count": failed_count,
        "success_rate": round(success_rate, 2),
        "average_execution_time": round(avg_time, 2),
        "total_config_size": total_config_size,
        "device_count": device_count,
        "schedule_count": schedule_count
    }

@router.get("/device-backup-status", response_model=List[DeviceBackupStatus])
async def get_device_backup_status(
    db: Session = Depends(get_db)
):
    """
    获取所有设备的备份状态
    - 最后备份状态
    - 最后备份时间
    - 总备份次数
    - 成功率
    """
    devices = db.query(Device).all()
    results = []
    
    for device in devices:
        # 获取该设备的最近一条日志
        last_log = db.query(BackupExecutionLog).filter(
            BackupExecutionLog.device_id == device.id
        ).order_by(desc(BackupExecutionLog.created_at)).first()
        
        # 获取该设备的所有日志
        all_logs = db.query(BackupExecutionLog).filter(
            BackupExecutionLog.device_id == device.id
        ).all()
        
        total = len(all_logs)
        success = len([log for log in all_logs if log.status == "success"])
        success_rate = (success / total * 100) if total > 0 else 0.0
        
        results.append({
            "device_id": device.id,
            "device_name": device.hostname or device.name,
            "last_backup_status": last_log.status if last_log else None,
            "last_backup_time": last_log.created_at if last_log else None,
            "total_backups": total,
            "success_rate": round(success_rate, 2)
        })
    
    return results

@router.get("/recent-executions", response_model=List[ExecutionLogResponse])
async def get_recent_executions(
    limit: int = Query(20, description="返回数量"),
    status: Optional[str] = Query(None, description="按状态筛选"),
    db: Session = Depends(get_db)
):
    """
    获取最近执行记录
    """
    query = db.query(BackupExecutionLog).join(
        Device, BackupExecutionLog.device_id == Device.id
    )
    
    if status:
        query = query.filter(BackupExecutionLog.status == status)
    
    logs = query.order_by(desc(BackupExecutionLog.created_at)).limit(limit).all()
    
    results = []
    for log in logs:
        device = db.query(Device).filter(Device.id == log.device_id).first()
        results.append({
            "id": log.id,
            "task_id": log.task_id,
            "device_id": log.device_id,
            "device_name": device.hostname if device else "Unknown",
            "status": log.status,
            "execution_time": log.execution_time,
            "started_at": log.started_at,
            "completed_at": log.completed_at,
            "error_message": log.error_message
        })
    
    return results

@router.get("/execution-trend", response_model=ExecutionTrend)
async def get_execution_trend(
    days: int = Query(7, description="天数"),
    db: Session = Depends(get_db)
):
    """
    获取执行趋势数据
    - 用于图表展示
    """
    end_date = datetime.now()
    start_date = end_date - timedelta(days=days)
    
    # 生成日期列表
    dates = []
    current_date = start_date
    while current_date <= end_date:
        dates.append(current_date.strftime("%Y-%m-%d"))
        current_date += timedelta(days=1)
    
    success_counts = []
    failure_counts = []
    average_times = []
    
    for date_str in dates:
        date_start = datetime.strptime(date_str, "%Y-%m-%d")
        date_end = date_start + timedelta(days=1)
        
        # 成功次数
        success = db.query(func.count(BackupExecutionLog.id)).filter(
            BackupExecutionLog.created_at >= date_start,
            BackupExecutionLog.created_at < date_end,
            BackupExecutionLog.status == "success"
        ).scalar()
        success_counts.append(success)
        
        # 失败次数
        failure = db.query(func.count(BackupExecutionLog.id)).filter(
            BackupExecutionLog.created_at >= date_start,
            BackupExecutionLog.created_at < date_end,
            BackupExecutionLog.status == "failed"
        ).scalar()
        failure_counts.append(failure)
        
        # 平均执行时间
        avg_time = db.query(func.avg(BackupExecutionLog.execution_time)).filter(
            BackupExecutionLog.created_at >= date_start,
            BackupExecutionLog.created_at < date_end,
            BackupExecutionLog.execution_time.isnot(None)
        ).scalar() or 0.0
        average_times.append(round(avg_time, 2))
    
    return {
        "dates": dates,
        "success_counts": success_counts,
        "failure_counts": failure_counts,
        "average_times": average_times
    }
```

**Step 5: 在main.py注册路由**

```python
# app/main.py
from app.routers import monitoring

app.include_router(monitoring.router)
```

**Step 6: 运行测试验证通过**

```bash
pytest tests/unit/test_monitoring_api.py -v
```

预期: PASS

**Step 7: 提交变更**

```bash
git add app/routers/monitoring.py app/schemas/monitoring.py tests/unit/test_monitoring_api.py app/main.py
git commit -m "feat: 新增备份监控统计API"
```

---

### 任务4: 前端实现监控面板组件

**涉及文件:**
- 修改: `frontend/src/api/monitoringApi.js` (新建)
- 新增: `frontend/src/components/BackupMonitoringPanel.vue`
- 新增: `frontend/src/views/BackupMonitoring.vue`
- 新增: `tests/unit/testMonitoringPanel.spec.js`

**Step 1: 编写失败的测试**

```javascript
// frontend/tests/unit/testMonitoringPanel.spec.js
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { mount } from '@vue/test-utils'
import BackupMonitoringPanel from '@/components/BackupMonitoringPanel.vue'
import { monitoringApi } from '@/api/monitoringApi'

vi.mock('@/api/monitoringApi', () => ({
  monitoringApi: {
    getBackupStatistics: vi.fn(),
    getDeviceBackupStatus: vi.fn(),
    getRecentExecutions: vi.fn(),
    getExecutionTrend: vi.fn()
  }
}))

describe('备份监控面板测试', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('应该显示统计卡片', async () => {
    monitoringApi.getBackupStatistics.mockResolvedValue({
      total_executions: 100,
      success_rate: 95.5,
      average_execution_time: 3.2,
      device_count: 10,
      schedule_count: 5
    })

    const wrapper = mount(BackupMonitoringPanel)
    
    await wrapper.vm.loadStatistics()
    
    expect(wrapper.text()).toContain('100')
    expect(wrapper.text()).toContain('95.5%')
  })

  it('应该显示设备备份状态表格', async () => {
    monitoringApi.getDeviceBackupStatus.mockResolvedValue([
      { device_id: 1, device_name: 'Switch-1', last_backup_status: 'success', success_rate: 100 }
    ])

    const wrapper = mount(BackupMonitoringPanel)
    
    await wrapper.vm.loadDeviceStatus()
    
    expect(wrapper.find('table').exists()).toBe(true)
    expect(wrapper.text()).toContain('Switch-1')
  })

  it('应该在加载失败时显示错误', async () => {
    monitoringApi.getBackupStatistics.mockRejectedValue(new Error('Network error'))

    const wrapper = mount(BackupMonitoringPanel)
    
    await wrapper.vm.loadStatistics()
    
    expect(wrapper.text()).toContain('加载失败')
  })
})
```

**Step 2: 运行测试验证失败**

```bash
npm run test:unit -- testMonitoringPanel.spec.js
```

预期: FAIL - 组件或API不存在

**Step 3: 创建监控API接口**

```javascript
// frontend/src/api/monitoringApi.js
import request from '@/utils/request'

export const monitoringApi = {
  /**
   * 获取备份统计信息
   * @param {number} days - 统计天数
   * @returns {Promise}
   */
  getBackupStatistics(days = 30) {
    return request({
      url: '/monitoring/backup-statistics',
      method: 'get',
      params: { days }
    })
  },

  /**
   * 获取设备备份状态
   * @returns {Promise}
   */
  getDeviceBackupStatus() {
    return request({
      url: '/monitoring/device-backup-status',
      method: 'get'
    })
  },

  /**
   * 获取最近执行记录
   * @param {number} limit - 返回数量
   * @param {string} status - 按状态筛选
   * @returns {Promise}
   */
  getRecentExecutions(limit = 20, status = null) {
    return request({
      url: '/monitoring/recent-executions',
      method: 'get',
      params: { limit, status }
    })
  },

  /**
   * 获取执行趋势数据
   * @param {number} days - 天数
   * @returns {Promise}
   */
  getExecutionTrend(days = 7) {
    return request({
      url: '/monitoring/execution-trend',
      method: 'get',
      params: { days }
    })
  }
}
```

**Step 4: 创建监控面板组件**

```vue
<!-- frontend/src/components/BackupMonitoringPanel.vue -->
<template>
  <div class="monitoring-panel">
    <!-- 统计卡片区域 -->
    <el-row :gutter="20" class="statistics-cards">
      <el-col :span="6">
        <el-card class="stat-card" shadow="hover">
          <div class="stat-content">
            <div class="stat-icon success">
              <el-icon><Check /></el-icon>
            </div>
            <div class="stat-info">
              <div class="stat-value">{{ statistics.success_rate }}%</div>
              <div class="stat-label">成功率</div>
            </div>
          </div>
        </el-card>
      </el-col>
      
      <el-col :span="6">
        <el-card class="stat-card" shadow="hover">
          <div class="stat-content">
            <div class="stat-icon total">
              <el-icon><Document /></el-icon>
            </div>
            <div class="stat-info">
              <div class="stat-value">{{ statistics.total_executions }}</div>
              <div class="stat-label">执行次数</div>
            </div>
          </div>
        </el-card>
      </el-col>
      
      <el-col :span="6">
        <el-card class="stat-card" shadow="hover">
          <div class="stat-content">
            <div class="stat-icon time">
              <el-icon><Timer /></el-icon>
            </div>
            <div class="stat-info">
              <div class="stat-value">{{ statistics.average_execution_time }}s</div>
              <div class="stat-label">平均耗时</div>
            </div>
          </div>
        </el-card>
      </el-col>
      
      <el-col :span="6">
        <el-card class="stat-card" shadow="hover">
          <div class="stat-content">
            <div class="stat-icon devices">
              <el-icon><Monitor /></el-icon>
            </div>
            <div class="stat-info">
              <div class="stat-value">{{ statistics.device_count }}</div>
              <div class="stat-label">设备数量</div>
            </div>
          </div>
        </el-card>
      </el-col>
    </el-row>

    <!-- 趋势图表 -->
    <el-row :gutter="20" class="chart-section">
      <el-col :span="16">
        <el-card class="chart-card">
          <template #header>
            <div class="card-header">
              <span>执行趋势</span>
              <el-radio-group v-model="trendDays" size="small" @change="loadTrend">
                <el-radio-button label="7">7天</el-radio-button>
                <el-radio-button label="14">14天</el-radio-button>
                <el-radio-button label="30">30天</el-radio-button>
              </el-radio-group>
            </div>
          </template>
          <div ref="trendChartRef" class="trend-chart"></div>
        </el-card>
      </el-col>
      
      <el-col :span="8">
        <el-card class="chart-card">
          <template #header>
            <span>执行状态分布</span>
          </template>
          <div ref="pieChartRef" class="pie-chart"></div>
        </el-card>
      </el-col>
    </el-row>

    <!-- 设备状态表格 -->
    <el-card class="device-table-card">
      <template #header>
        <div class="card-header">
          <span>设备备份状态</span>
          <el-button type="primary" link @click="loadDeviceStatus">
            <el-icon><Refresh /></el-icon>
            刷新
          </el-button>
        </div>
      </template>
      
      <el-table :data="deviceStatus" v-loading="loadingDeviceStatus">
        <el-table-column prop="device_name" label="设备名称" />
        <el-table-column prop="last_backup_status" label="最后备份状态">
          <template #default="{ row }">
            <el-tag :type="getStatusType(row.last_backup_status)">
              {{ row.last_backup_status || '从未备份' }}
            </el-tag>
          </template>
        </el-table-column>
        <el-table-column prop="last_backup_time" label="最后备份时间">
          <template #default="{ row }">
            {{ formatTime(row.last_backup_time) }}
          </template>
        </el-table-column>
        <el-table-column prop="total_backups" label="总备份次数" />
        <el-table-column prop="success_rate" label="成功率">
          <template #default="{ row }">
            <el-progress 
              :percentage="row.success_rate" 
              :color="getProgressColor(row.success_rate)"
            />
          </template>
        </el-table-column>
      </el-table>
    </el-card>

    <!-- 最近执行记录 -->
    <el-card class="recent-logs-card">
      <template #header>
        <div class="card-header">
          <span>最近执行记录</span>
          <el-select v-model="logFilter" size="small" placeholder="筛选状态" clearable>
            <el-option label="全部" value="" />
            <el-option label="成功" value="success" />
            <el-option label="失败" value="failed" />
          </el-select>
        </div>
      </template>
      
      <el-table :data="recentExecutions" v-loading="loadingExecutions">
        <el-table-column prop="device_name" label="设备" />
        <el-table-column prop="status" label="状态">
          <template #default="{ row }">
            <el-tag :type="getStatusType(row.status)">{{ row.status }}</el-tag>
          </template>
        </el-table-column>
        <el-table-column prop="execution_time" label="耗时">
          <template #default="{ row }">
            {{ row.execution_time ? `${row.execution_time}s` : '-' }}
          </template>
        </el-table-column>
        <el-table-column prop="started_at" label="开始时间">
          <template #default="{ row }">
            {{ formatTime(row.started_at) }}
          </template>
        </el-table-column>
        <el-table-column prop="error_message" label="错误信息" show-overflow-tooltip>
          <template #default="{ row }">
            <span v-if="row.status === 'failed'" class="error-text">
              {{ row.error_message }}
            </span>
            <span v-else>-</span>
          </template>
        </el-table-column>
      </el-table>
    </el-card>
  </div>
</template>

<script>
import { ref, onMounted, onUnmounted } from 'vue'
import { monitoringApi } from '@/api/monitoringApi'
import * as echarts from 'echarts'

export default {
  name: 'BackupMonitoringPanel',
  setup() {
    const statistics = ref({
      total_executions: 0,
      success_rate: 0,
      average_execution_time: 0,
      device_count: 0,
      schedule_count: 0
    })
    
    const deviceStatus = ref([])
    const recentExecutions = ref([])
    const trendData = ref({ dates: [], success_counts: [], failure_counts: [] })
    const trendDays = ref(7)
    const loadingDeviceStatus = ref(false)
    const loadingExecutions = ref(false)
    const logFilter = ref('')
    
    let trendChart = null
    let pieChart = null
    let refreshTimer = null
    
    const trendChartRef = ref(null)
    const pieChartRef = ref(null)
    
    const loadStatistics = async () => {
      try {
        const response = await monitoringApi.getBackupStatistics()
        statistics.value = response
        updatePieChart()
      } catch (error) {
        console.error('加载统计信息失败:', error)
      }
    }
    
    const loadDeviceStatus = async () => {
      loadingDeviceStatus.value = true
      try {
        const response = await monitoringApi.getDeviceBackupStatus()
        deviceStatus.value = response
      } catch (error) {
        console.error('加载设备状态失败:', error)
      } finally {
        loadingDeviceStatus.value = false
      }
    }
    
    const loadRecentExecutions = async () => {
      loadingExecutions.value = true
      try {
        const response = await monitoringApi.getRecentExecutions(20, logFilter.value || null)
        recentExecutions.value = response
      } catch (error) {
        console.error('加载执行记录失败:', error)
      } finally {
        loadingExecutions.value = false
      }
    }
    
    const loadTrend = async () => {
      try {
        const response = await monitoringApi.getExecutionTrend(trendDays.value)
        trendData.value = response
        updateTrendChart()
      } catch (error) {
        console.error('加载趋势数据失败:', error)
      }
    }
    
    const updateTrendChart = () => {
      if (!trendChart) return
      
      trendChart.setOption({
        tooltip: { trigger: 'axis' },
        legend: { data: ['成功', '失败'] },
        xAxis: {
          type: 'category',
          data: trendData.value.dates
        },
        yAxis: { type: 'value' },
        series: [
          {
            name: '成功',
            type: 'bar',
            data: trendData.value.success_counts,
            itemStyle: { color: '#67c23a' }
          },
          {
            name: '失败',
            type: 'bar',
            data: trendData.value.failure_counts,
            itemStyle: { color: '#f56c6c' }
          }
        ]
      })
    }
    
    const updatePieChart = () => {
      if (!pieChart) return
      
      const success = statistics.value.success_count || 0
      const failed = statistics.value.failed_count || 0
      
      pieChart.setOption({
        tooltip: { trigger: 'item' },
        legend: { bottom: '5%' },
        series: [{
          type: 'pie',
          radius: ['40%', '70%'],
          avoidLabelOverlap: false,
          label: { show: false },
          data: [
            { value: success, name: '成功', itemStyle: { color: '#67c23a' } },
            { value: failed, name: '失败', itemStyle: { color: '#f56c6c' } }
          ]
        }]
      })
    }
    
    const initCharts = () => {
      if (trendChartRef.value) {
        trendChart = echarts.init(trendChartRef.value)
      }
      if (pieChartRef.value) {
        pieChart = echarts.init(pieChartRef.value)
      }
    }
    
    const getStatusType = (status) => {
      const types = {
        success: 'success',
        failed: 'danger',
        timeout: 'warning',
        cancelled: 'info'
      }
      return types[status] || 'info'
    }
    
    const getProgressColor = (percentage) => {
      if (percentage >= 90) return '#67c23a'
      if (percentage >= 70) return '#e6a23c'
      return '#f56c6c'
    }
    
    const formatTime = (time) => {
      if (!time) return '-'
      return new Date(time).toLocaleString('zh-CN')
    }
    
    const startAutoRefresh = () => {
      refreshTimer = setInterval(() => {
        loadStatistics()
        loadRecentExecutions()
      }, 30000) // 每30秒刷新
    }
    
    onMounted(() => {
      initCharts()
      loadStatistics()
      loadDeviceStatus()
      loadRecentExecutions()
      loadTrend()
      startAutoRefresh()
    })
    
    onUnmounted(() => {
      if (refreshTimer) clearInterval(refreshTimer)
      if (trendChart) trendChart.dispose()
      if (pieChart) pieChart.dispose()
    })
    
    return {
      statistics,
      deviceStatus,
      recentExecutions,
      trendData,
      trendDays,
      loadingDeviceStatus,
      loadingExecutions,
      logFilter,
      trendChartRef,
      pieChartRef,
      loadStatistics,
      loadDeviceStatus,
      loadRecentExecutions,
      loadTrend,
      getStatusType,
      getProgressColor,
      formatTime
    }
  }
}
</script>

<style scoped>
.monitoring-panel {
  padding: 20px;
}

.statistics-cards {
  margin-bottom: 20px;
}

.stat-card {
  border-radius: 8px;
}

.stat-content {
  display: flex;
  align-items: center;
  gap: 16px;
}

.stat-icon {
  width: 48px;
  height: 48px;
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24px;
  color: white;
}

.stat-icon.success { background: linear-gradient(135deg, #67c23a 0%, #85ce61 100%); }
.stat-icon.total { background: linear-gradient(135deg, #409eff 0%, #66b1ff 100%); }
.stat-icon.time { background: linear-gradient(135deg, #e6a23c 0%, #f5d14b 100%); }
.stat-icon.devices { background: linear-gradient(135deg, #909399 0%, #b4b4b8 100%); }

.stat-value {
  font-size: 24px;
  font-weight: bold;
  color: #303133;
}

.stat-label {
  font-size: 14px;
  color: #909399;
}

.chart-section {
  margin-bottom: 20px;
}

.chart-card {
  height: 400px;
}

.trend-chart,
.pie-chart {
  height: 300px;
}

.card-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.device-table-card,
.recent-logs-card {
  margin-bottom: 20px;
}

.error-text {
  color: #f56c6c;
  font-size: 12px;
}
</style>
```

**Step 5: 运行测试验证通过**

```bash
npm run test:unit -- testMonitoringPanel.spec.js
```

预期: PASS

**Step 6: 提交变更**

```bash
git add frontend/src/api/monitoringApi.js frontend/src/components/BackupMonitoringPanel.vue
git commit -m "feat: 实现备份监控面板组件和API"
```

---

### 任务5: 添加路由和菜单

**涉及文件:**
- 修改: `frontend/src/router/index.js`
- 修改: `frontend/src/views/MainLayout.vue` 或菜单配置文件

**Step 1: 添加路由**

```javascript
// frontend/src/router/index.js
{
  path: '/monitoring',
  name: 'BackupMonitoring',
  component: () => import('@/views/BackupMonitoring.vue'),
  meta: { title: '备份监控', icon: 'monitor' }
}
```

**Step 2: 添加菜单项**

```vue
<!-- 在菜单中添加 -->
<el-menu-item index="/monitoring">
  <el-icon><Monitor /></el-icon>
  <span>备份监控</span>
</el-menu-item>
```

**Step 3: 运行前端lint检查**

```bash
cd frontend
npm run lint
```

预期: 无错误

**Step 4: 提交变更**

```bash
git add frontend/src/router/index.js
git commit -m "feat: 添加备份监控路由和菜单"
```

---

## 验收标准

1. [ ] `backup_execution_logs` 表正确创建，包含所有必要字段
2. [ ] 调度器执行备份时自动记录执行日志
3. [ ] 监控API返回正确的统计数据
4. [ ] 监控面板显示统计卡片、趋势图表、设备状态表格
5. [ ] 监控数据支持自动刷新
6. [ ] 所有单元测试和集成测试通过
7. [ ] 前端lint检查通过

## 相关文档

- 原始需求: `docs/功能需求/前端/配置管理模块问题分析与优化方案.md`
- 备份调度器: `app/services/backup_scheduler.py`
- 数据库模型: `app/models/models.py`
